<html><head><style>body {
   color: black;
}
</style></head><body><h2 id="unity-for-games-e-book">UNITY FOR GAMES E-BOOK</h2>
<p><img src="_page_0_Picture_2.jpeg" alt=""></p>
<h1 id="2-d-g-a-m-e-a-r-t-a-n-i-m-a-t-i-o-n-a-n-d-l-i-g-h-t-i-n-g-f-o-r-a-r-t-i-s-t-s">2 D G A M E A R T , A N I M A T I O N , A N D L I G H T I N G F O R A R T I S T S</h1>
<p><img src="_page_0_Picture_4.jpeg" alt=""></p>
<h2 id="-contents-"><strong>Contents</strong></h2>
<table>
<thead>
<tr>
<th>Painting the Mask Map 86</th>
</tr>
</thead>
<tbody>
<tr>
<td>Setting Fresnel light 86</td>
</tr>
<tr>
<td>2D Tilemap 88</td>
</tr>
<tr>
<td>2D Sprite Shape 89</td>
</tr>
<tr>
<td>2D PSD Importer for animated characters 90</td>
</tr>
<tr>
<td>Advanced visual effects 92</td>
</tr>
<tr>
<td>Main Module properties 95</td>
</tr>
<tr>
<td>Emission 95</td>
</tr>
<tr>
<td>Shape 95</td>
</tr>
<tr>
<td>Color over Lifetime 95</td>
</tr>
<tr>
<td>Size Over Lifetime 95</td>
</tr>
<tr>
<td>Rotation Over Lifetime 95</td>
</tr>
<tr>
<td>Noise 95</td>
</tr>
<tr>
<td>Renderer 96</td>
</tr>
<tr>
<td>Randomized particles 96</td>
</tr>
<tr>
<td>Using the Shader Graph 97</td>
</tr>
<tr>
<td>Reflections and refractions 105</td>
</tr>
<tr>
<td>Post-processing. 110</td>
</tr>
<tr>
<td>Local Volumes 112</td>
</tr>
<tr>
<td>Bloom 114</td>
</tr>
<tr>
<td>Chromatic Aberration 114</td>
</tr>
<tr>
<td>Color Grading 115</td>
</tr>
<tr>
<td>Lens Distortion<br>. 116</td>
</tr>
<tr>
<td>Vignette 116</td>
</tr>
<tr>
<td>Film Grain 117</td>
</tr>
<tr>
<td>Panini Projection 117</td>
</tr>
<tr>
<td>Conclusion. 118</td>
</tr>
</tbody>
</table>
<h2 id="-span-id-page-3-0-span-introduction-"><span id="page-3-0"></span><strong>Introduction</strong></h2>
<p>2D games evoke nostalgia for people who grew up playing them in the 1980s and &#39;90s. But as <a href="https://youtu.be/IjJ9j_HYgGI?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=clean-code-that-scales--ebook">made-with-Unity titles</a> such as <em>Cuphead</em>, <em>Hollow Knight</em>, <em>Among Us</em>, <em>Skul: The Hero Slayer,</em> and the <em>Ori</em> series show, there is no limit to how innovative today&#39;s 2D games can be.</p>
<p>The evolution of hardware, graphics, and game development software makes it possible to create 2D games with real-time lights, high-resolution textures, and an almost unlimited sprite count. The flatness of 2D graphics frees artists to create cartoonish and fantastical art that looks great on any device.</p>
<p>This is our biggest, most comprehensive 2D game development guide. It&#39;s intended for developers and artists with intermediate Unity experience who want to make a commercial 2D game, whether they work independently or with a team.</p>
<p>This guide was written with input from Unity 2D experts to help up-and-coming creators understand the key decisions they should make at the start of a project and get the most out of the Unity 2D toolset.</p>
<p>Topics covered include setting up your project, round-tripping between Unity and your digital content creation (DCC) software, sprite creation, and layer sorting for level design, camera setup, animation, lights, and visual effects, plus many optimization tips along the way.</p>
<p>Even if you are new to Unity, you&#39;ll find plenty of useful tips and practices in the guide. However, we suggest you start with the beginner tutorials and courses available for free at <a href="https://learn.unity.com/?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Unity Learn.</a> We hope you enjoy this guide and wish you the best of luck with your game development. The future is bright for 2D creators.</p>
<p><img src="_page_3_Picture_7.jpeg" alt=""></p>
<p>Some beautiful 2D games made with Unity – clockwise from top left: <em>Ori and the Will of the Wisps</em> by Moon Studios, <em>Cuphead</em> by Studio MDHR, <em>MegaSphere</em> by AK Games <em>Hollow Knight</em> by Team Cherry</p>
<h4 id="author">Author</h4>
<p>Jarek Majewski is a professional 2D artist and self-taught Unity developer with extensive C# scripting skills. He has created art for iOS, Xbox Indie Live, and Nintendo Switch™ games. His game <em>Ultimate Action Hero,</em> currently in development, placed second in the <a href="https://blog.unity.com/community/announcing-the-unity-2d-challenge-winners?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">2019 Unity 2D Challenge.</a> Jarek was the art director for <em><a href="https://blog.unity.com/technology/get-to-know-dragon-crashers-our-latest-2d-sample-project?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Dragon Crashers</a></em>, a 2D demo project developed together with 2D experts from Unity. The demo project uses the 2D features available in Unity 2020 LTS.</p>
<p>Jarek worked closely with numerous Unity experts and employees to write this definitive guide to creating 2D games.</p>
<h4 id="unity-contributors">Unity contributors</h4>
<p><a href="https://twitter.com/EduOriz">Eduardo Oriz</a> led the production of this guide. He is a senior content marketing manager at Unity with many years of experience working with Unity development teams, including the 2D tools team, and a broad understanding of what Unity offers to game developers and studios.</p>
<p><a href="https://twitter.com/rustumscammell">Rus Scammell</a> is the product manager on Unity&#39;s 2D development team. Rus has over 15 years&#39; experience in game and software development. He uses his extensive knowledge of games technology to ensure that Unity 2D tools and workflows are accessible to artists, programmers, and game designers.</p>
<p><a href="https://twitter.com/andytouch">Andy Touch</a> is a senior content developer at Unity who has worked on many projects, including <em><a href="https://blog.unity.com/technology/download-our-new-2d-sample-project-lost-crypt?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Lost Crypt</a></em> and <em>Dragon Crashers</em>. Ever since he downloaded Unity, added 3D physics to 100 cubes and watched them bounce around, Andy has been addicted to experimenting with game technology. Before joining Unity, Andy taught game development to university students.</p>
<p>Finally, thanks to supporting contributors, including copywriters, editors, and graphic designers, and the countless others at Unity who helped to produce, refine, and share this guide.</p>
<p>Please note that the tips and workflows in this e-book are based on the 2D toolset in the Unity 2020 LTS version, however.... using new versions of Unity, including Unity 2021 LTS.</p>
<p>*Nintendo Switch is a trademark of Nintendo.</p>
<h2 id="-span-id-page-5-0-span-project-setup-2d-rendering-"><span id="page-5-0"></span><strong>Project setup: 2D rendering</strong></h2>
<p>Unity provides <a href="https://docs.unity3d.com/Manual/render-pipelines-overview.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">three render pipelines:</a> the Built-In Render Pipeline and two Scriptable Render Pipelines (SRPs). The two SRPs are the <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Universal Render</a>  <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Pipeline</a> (URP) and the <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@10.7/manual/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">High Definition Render Pipeline</a> (HDRP). URP applies to all platforms, while HDRP is designed to be used in games targeting high-end PCs and consoles.</p>
<p>URP is used in this book because it provides a graphics pipeline for <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/Lights-2D-intro.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">2D Lighting,</a> allowing you to create 2D lights and lighting effects, including <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/LightTypes.html#freeform?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Freeform,</a> <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/LightTypes.html#sprite?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Sprite</a>, <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/LightTypes.html#spot?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Spot,</a> and <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/LightTypes.html#global?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Global</a>. The URP is also compatible with the <a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@10.7/manual/index.html">Shader Graph</a>, <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/integration-with-post-processing.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">post</a><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/integration-with-post-processing.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">processing effects,</a> and the camera stacking feature.</p>
<p>To use the 2D Renderer, you&#39;ll first need to install the 2D Project template from the Unity Hub and the URP. The 2D template comes with several project settings that are optimized for a 2D game:</p>
<ul>
<li>The images are imported as Sprites and set to <a href="https://docs.unity3d.com/Manual/SpritePacker.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Sprite</a> mode</li>
<li>The <a href="https://docs.unity3d.com/Manual/UsingTheSceneView.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Scene view</a> is set to 2D</li>
<li>The default scene does not include a light</li>
<li>The camera&#39;s default position is at 0, 0, –10</li>
<li>The camera is set to <a href="https://docs.unity3d.com/Manual/class-Camera.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Orthographic</a></li>
<li>In the <a href="https://docs.unity3d.com/Manual/LightingOverview.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Lighting</a> window settings:<ul>
<li>All Global Illumination is disabled</li>
<li>Skybox material is set to none</li>
<li>Ambient Source is set to Color</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Create a new project with Unity 2020.3.19f1</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>-</th>
<th>0</th>
<th>×</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Templates</td>
<td></td>
<td></td>
<td>Settings</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>Project Name *<br>New Awesome 2D Unity Project</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>11<br>2D</td>
<td>3D</td>
<td>High Definition RP</td>
<td>Location *<br>C:\Projects</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>0</td>
<td>14</td>
<td>14<br>പ്ര</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Universal Render<br>Pipeline</td>
<td>2D Platformer<br>Microgame</td>
<td>Karting Microgame</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>14</td>
<td>中</td>
<td>中</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>CANCEL</td>
<td></td>
<td>CREATE</td>
</tr>
</tbody>
</table>
<p>The Unity Hub window</p>
<h4 id="-choose-2d-packages-from-the-package-manager-"><strong>Choose 2D packages from the Package Manager</strong></h4>
<p>If you have used Unity before, you know that many features are available as <a href="https://docs.unity3d.com/2021.2/Documentation/Manual/upm-ui.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">modular packages.</a> You can see which versions of each package are available via <strong>Window &gt; Package Manager</strong> in the Editor. You can install, remove, disable, or update packages for each project here as well. The packages included in the 2D Template are <a href="https://docs.unity3d.com/Packages/com.unity.2d.animation@5.0/manual/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">2D Animation</a>, <a href="https://docs.unity3d.com/Packages/com.unity.2d.pixel-perfect@4.0/manual/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">2D Pixel Perfect</a>, <a href="https://docs.unity3d.com/Packages/com.unity.2d.psdimporter@4.1/manual/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">2D PSD Importer</a>, and <a href="https://docs.unity3d.com/Packages/com.unity.2d.spriteshape@5.1/manual/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">2D</a>  <a href="https://docs.unity3d.com/Packages/com.unity.2d.spriteshape@5.1/manual/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">SpriteShape.</a></p>
<p>Next, you will need to install the URP through the Package Manager.</p>
<table>
<thead>
<tr>
<th>Package Manager</th>
<th></th>
<th>: ■×</th>
</tr>
</thead>
<tbody>
<tr>
<td>+ + Packages: Unity Registry + Sort: Name ↓ ▼<br>WHILE DEGIME</td>
<td>6.0.6</td>
<td>8 9</td>
</tr>
<tr>
<td>Remote Config</td>
<td>1.4.0</td>
<td>Universal RP</td>
</tr>
<tr>
<td>Scriptable Build Pipeline</td>
<td>1.19.3</td>
<td></td>
</tr>
<tr>
<td>Shader Graph</td>
<td>10.6.0</td>
<td>Unity Technologies<br>Version 10.6.0 - July 08, 2021</td>
</tr>
<tr>
<td>Test Framework</td>
<td>1.1.29 G</td>
<td>View documentation · View changelog · View licenses</td>
</tr>
<tr>
<td>TextMesh Pro</td>
<td>3.0.6 V</td>
<td></td>
</tr>
<tr>
<td>Timeline</td>
<td>1.4.8 V</td>
<td>The Universal Render Pipeline (URP) is a prebuilt Scriptable Render Pipeline, made by Unity. URP provides<br>artist-friendly workflows that let you quickly and easily create optimized graphics across a range of platforms, from</td>
</tr>
<tr>
<td>Unity Distribution Portal</td>
<td>2.0.0</td>
<td>mobile to high-end consoles and PCs.<br>More</td>
</tr>
<tr>
<td>Unity Recorder</td>
<td>2.5.7 V</td>
<td>Registry Unity</td>
</tr>
<tr>
<td>Unity Ul</td>
<td>1.0.0 V</td>
<td></td>
</tr>
<tr>
<td>Universal RP</td>
<td>10.6.0</td>
<td></td>
</tr>
<tr>
<td>Version Control</td>
<td>1.9.0 V</td>
<td></td>
</tr>
<tr>
<td>Visual Effect Graph</td>
<td>10.6.0</td>
<td></td>
</tr>
<tr>
<td>Visual Studio Code Editor</td>
<td>1.2.4 V</td>
<td></td>
</tr>
<tr>
<td>Last update Nov 11, 13:45</td>
<td>C +</td>
<td>Instal</td>
</tr>
</tbody>
</table>
<p>Install URP from the Package Manager</p>
<p><img src="_page_7_Picture_0.jpeg" alt=""></p>
<p>Creating a URP asset</p>
<h4 id="-create-a-new-urp-asset-"><strong>Create a new URP Asset</strong></h4>
<p>To use the URP, create a <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/universalrp-asset.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">URP Asset</a> and assign the asset in the Graphics settings.</p>
<p>Right-click in the Project window (or click in the Assets menu in the Toolbar), and choose <strong>Assets &gt; Create &gt; Rendering &gt; Universal Render Pipeline &gt; Pipeline Asset (Forward Renderer)</strong>.</p>
<p>A Renderer Asset is created at the same time as a URP Asset, and you will need to replace this with the 2D Renderer Asset. To replace it, right-click in the Project window or click in the Assets menu, then choose <strong>Assets &gt; Create &gt; Rendering &gt; Universal Render Pipeline &gt; 2D Renderer</strong>.</p>
<h4 id="-assign-the-2d-renderer-"><strong>Assign the 2D Renderer</strong></h4>
<p>Click on the URP Asset, and, in the Inspector, assign the 2D Renderer Asset to the <strong>Renderer List.</strong> Click on the circular button at the right end of the field to select it from the list.</p>
<p><img src="_page_7_Picture_8.jpeg" alt=""></p>
<p>Setting a new renderer in the Inspector view for the URP asset</p>
<p>Now that you have the URP and 2D Renderer Assets lined up, assign the 2D Renderer to the Scriptable Render Pipeline Settings in the project. Open the Project Settings window (<strong>Edit &gt; Projects Settings</strong>), go to the Graphics section, and assign the Pipeline Asset here.</p>
<p><img src="_page_8_Picture_1.jpeg" alt=""></p>
<p>Assign the Universal Render Pipeline Assets in Project Settings</p>
<p>The 2D Renderer is now set up and ready to go. You can also adjust the rendering settings by switching to the Quality category in Project settings. Read more about rendering setting<a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@10.7/manual/Setup.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">s</a> <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@10.7/manual/Setup.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">here</a>.</p>
<p><strong>Note:</strong> If you start a new project in Unity 2021 or later, the 2D template, called 2D (URP), comes with the 2D Renderer already set up, so you won&#39;t have to complete these steps.</p>
<h2 id="-span-id-page-9-0-span-the-art-for-your-game-"><span id="page-9-0"></span><strong>The art for your game</strong></h2>
<p>During the art concept phase, you&#39;ll need to make many decisions that will impact the technical side of your project.</p>
<p>In game design, it&#39;s a common practice to mock up a screenshot or series of images to show the game&#39;s art style, action, and UI. Mockups are a quick way to determine if the concept is viable and get a sense of how the final game would look.</p>
<p>You can also explore multiple art directions with simple thumbnail mockups. These mockups would have simplified shapes and focus more on the overall look, camera angle, object sizes, color palette, and contrast. Using thumbnails is a great way to present different approaches to the team for testing and iteration.</p>
<p><img src="_page_9_Picture_4.jpeg" alt=""></p>
<p>Testing ideas by drawing simple thumbnails</p>
<p>A few things to consider when making a mockup:</p>
<ul>
<li>What will be the camera angle and perspective of your game?</li>
<li>What will be the size of the player character in relation to the screen size of your target platform?</li>
<li>Does your art style fit the target platform, theme, and audience? For example, will this style appeal to casual gamers, young players, strategy fans, and so on?</li>
<li>How does the art style fit with the overall graphics approach?<ul>
<li>If the gameplay requires fast reaction times, then it&#39;s a good idea to make elements such as the player character, enemies, and projectiles visible against the background at first glance.</li>
<li>Mobile games should be brighter and have higher contrast to be visible in the sunlight and smaller screens.</li>
</ul>
</li>
<li>What are the size, position, and visibility of GUI elements?</li>
</ul>
<h2 id="technical-considerations">Technical considerations</h2>
<p>There are also important technical questions to consider in the mockup stage. These include:</p>
<ul>
<li><strong>Animation:</strong> What elements will you animate with skeletal animation? Which ones will have frame-by-frame animation or be animated with a shader?</li>
<li><strong>Environment:</strong> Will you create it with Tilemap or Sprite Shapes? Or, do you want to place platform sprites in the scene manually? You can paint your mockup to mimic the look of these tools so that you can use the mockups directly in your game.</li>
<li><strong>Sorting:</strong> Plan your sprite sorting by grouping mockup layers similarly to how you anticipate the sorting will be done in Unity. It might take some time, but you&#39;ll avoid having to sort through potentially thousands of sprites later in production.</li>
<li><strong>Lighting:</strong> Will your sprites be lit with lighting and shadows painted onto them or with real-time lighting? One tip is to paint images with no lighting, then add shadows and lights on separate layers in your image-editing software. That way, you can always change the look of the lighting later in production if necessary.</li>
</ul>
<p>Take the time in this stage to create assets that are as close as possible to what they will look like in the final game. This allows you to move from concept to game production more quickly.</p>
<p><img src="_page_10_Picture_7.jpeg" alt=""></p>
<p>A comparison of the original concept art and the final version of <em>Dragon Crashers</em>. You can read about the process for creating the art for the demo in <a href="https://blog.unity.com/games/2d-art-creation-in-dragon-crashers">this blog post</a>.</p>
<h2 id="-span-id-page-11-0-span-choose-the-perspective-"><span id="page-11-0"></span><strong>Choose the perspective</strong></h2>
<p>There are different perspectives, or views, available for a 2D game. The umbrella term for perspective options is graphical projection, which refers to a method of casting a 3D world onto a 2D plane. You can see the different perspectives illustrated here.</p>
<p><img src="_page_11_Figure_2.jpeg" alt=""></p>
<h4 id="-parallel-projections-"><strong>Parallel projections</strong></h4>
<p>With these types of projections, the lines that are parallel in the 3D world are also parallel when projected onto a 2D surface. Additionally, they have no vanishing points, which means objects are the same size no matter their distance from the camera. This is useful in games because you don&#39;t have to scale your assets or draw them in different sizes.</p>
<p><img src="_page_11_Picture_5.jpeg" alt=""></p>
<p>This diagram illustrates how Orthographic projection works. Note that all the projection rays from the camera are parallel to one another and perpendicular to the image plane.</p>
<p>In Orthographic projection, the rays are perpendicular (orthogonal) to the image plane, while in oblique projection, rays intersect with the projection plane at an oblique angle to produce the projected image.</p>
<p>There are two subcategories of Orthographic projection: primary and axonometric.</p>
<h4 id="-primary-projection-"><strong>Primary projection</strong></h4>
<p>In primary projection, there is one dimension perpendicular to the view plane. Since all the lines in this dimension are parallel, it&#39;s not visible in the final projection. This kind of projection is the easiest to draw because you need to draw only two dimensions. Games will use one of two types of primary projections, side view or top-down.</p>
<p>Side view is used in platformers, shooters, and <em>Metroidvania</em>-style games. The X and Y axis of the 3D world are drawn on the screen with the Z axis omitted. Game artists tend to scale down distant objects visible in the background to provide a sense of depth.</p>
<p><img src="_page_12_Picture_5.jpeg" alt=""></p>
<p>Side view perspective in the 1991 version of <em>Sonic The Hedgehog™</em> by Sega</p>
<p>In top-down perspective, the camera aims down, perpendicular to the ground. There aren&#39;t many true top-down games, and this perspective is often confused with ¾ or isometric projections. Top-down works best for shooters, but it&#39;s not the most interesting view from which to view human characters.</p>
<p><img src="_page_12_Picture_8.jpeg" alt=""></p>
<p>Top-down perspective in <em>Alien Breed</em>™ by Team17, released in 1992 for the Amiga</p>
<h4 id="-axonometric-projection-"><strong>Axonometric projection</strong></h4>
<p>In axonometric projection, the 3D world is rotated around one or more axes to show multiple sides of objects.</p>
<p><img src="_page_13_Figure_2.jpeg" alt=""></p>
<p>There are three main types of axonometric projection.</p>
<p>Isometric, dimetric and trimetric projection</p>
<p><strong>Isometric projection</strong>: This projection is the most elegant of the three options. The angle between any two of the three coordinate axes is at 120 degrees, and the X and Y lines are each at a 30-degree angle from the horizontal axis.</p>
<p>Most of the old games referred to as isometric are in fact dimetric. Isometric projection angles don&#39;t look great in pixel art, which is why there aren&#39;t many games with true isometric projection.</p>
<p><strong>Dimetric projection:</strong> This perspective uses projection where two angles are identical, with the X and Y lines angled at 26.6 degrees. Dimetric has been the most common option because it looked better on the older hardware, where the lines formed a clear 2:1 pixel ratio.</p>
<p>You can use this projection to show more or less of the top surface.</p>
<p><strong>Trimetric projection:</strong> With this projection, each angle is different.</p>
<p><img src="_page_14_Picture_1.jpeg" alt=""></p>
<p>Trimetric projection in <em>Crystal Castles</em> by Atari, released in 1983</p>
<h4 id="-three-quarter-projection-"><strong>Three-quarter (¾) projection</strong></h4>
<p>This projection is often confused with top-down. In 3/4 projection, the camera tilts slightly on the X axis to reveal a partial view of the front of objects and characters.</p>
<p><img src="_page_14_Picture_5.jpeg" alt=""></p>
<p>¾ projection in <em>Bomberman World</em>, released in 1991 by Hundson Soft</p>
<h4 id="-oblique-projection-"><strong>Oblique projection</strong></h4>
<p>In oblique projection, rays intersect with the projection plane at an oblique angle to produce the projected image. The most common oblique projection variant is the cabinet projection, which is often used in beat &#39;em up games.</p>
<p><img src="_page_14_Picture_9.jpeg" alt=""></p>
<p>Oblique projection view in <em>Streets of Rage: Mega Drive</em>, released in 1991 by Sega</p>
<p><img src="_page_15_Picture_0.jpeg" alt=""></p>
<p>Perspective projection, where the projection rays are coming from the center of the projection camera.</p>
<h3 id="perspective-projection">Perspective projection</h3>
<p>Perspective projection uses vanishing points to replicate the way objects farther away appear smaller. A vanishing point is a point on the plane of a perspective drawing where the two-dimensional projections or drawings of mutually parallel lines in three-dimensional space appear to converge.</p>
<p>Depending on the number of vanishing points, you can have one- , two- or three-point perspectives. With the advent of 3D graphics, these projections are less common in 2D games, although they still work well for adventure games or games with static backgrounds.</p>
<p>How do you choose the correct perspective for your project? Does gameplay determine the art style or vice versa? In most cases, developers choose an art style and camera projection based on assumptions made when the idea for their game crystallizes. It will be a decision based on many criteria, including:</p>
<ul>
<li>Gameplay and genre</li>
<li>Target platform</li>
<li>Scene readability for example choosing a higher camera angle for better visibility of character and enemy units</li>
<li>Budget top-down and isometric games can require more character animations for multiple angles and more advanced coding</li>
<li>Target audience</li>
</ul>
<p>You can also base your game on an art style. For example, imagine a game based on ancient Egyptian hieroglyphs. In this case, the art theme will determine some camera and gameplay rules, namely, that it must be a side-view game with a primary perspective.</p>
<p>If you&#39;re new to 2D development or on a tight budget, it&#39;s better to choose one of the primary projections: top-down or side-view. They&#39;re easier to both draw and code. With only two dimensions visible, you have less to worry about, and it&#39;s easier to set up sprite sorting in these views.</p>
<p>Remember, in the end, your projection doesn&#39;t need to be 100% accurate and follow all the real-world rules strictly, as is the case in 3D space. The most important thing is that it needs to look good and enhance the gameplay.</p>
<h2 id="-span-id-page-16-0-span-resolution-of-your-assets-"><span id="page-16-0"></span><strong>Resolution of your assets</strong></h2>
<p>Unity&#39;s 2D tools have evolved from an editor built initially for 3D games. As a result, there are some unique features. For example, 2D sprites in the Scene aren&#39;t bound tightly to screen resolution. Sprites in Unity are textures drawn onto a mesh and are easily scalable. The camera in 2D games is also scalable and can zoom in and out as you want.</p>
<p>Therefore, creating 2D content in Unity requires a different approach to that of working in traditional raster graphics software such as Adobe Photoshop, Affinity Photo by Serif, GIMP, or Krita. In these conventional apps, you have a specific document canvas size available with a set resolution, and all layers are bound to this resolution. There is a 1:1 ratio between the pixel size of each layer and the document pixel size.</p>
<p><img src="_page_16_Picture_3.jpeg" alt=""></p>
<p>When drawing game assets, the pixel size is consistent, and the image looks great because it&#39;s always constrained to the pixel grid. However, in Unity, the sprites can have a different resolution. The camera zoom level will also affect the final look.</p>
<p>In Unity, however, screen and asset resolution are independent of each other, so you need to calculate the resolution of your sprites.</p>
<p>You start with your target platforms because the capabilities of the hardware determine the maximum resolution you can set.</p>
<p>For mobile devices, the resolution range is broad, but a safe assumption is 1920x1080, since this will allow you to target devices from low- to high-end.</p>
<p>For PCs, the majority of desktop gamers use full HD (1920x1080), while only 2% have 4K screens, according to a <a href="https://store.steampowered.com/hwsurvey/Steam-Hardware-Software-Survey-Welcome-to-Steam">survey from Steam</a>. For laptops specifically, there are a lot of users who play games at lower resolutions such as 1366x768. You might also want to consider supporting ultra-wide screens, making sure you test screen ratios like 21:9 to ensure the camera won&#39;t display unwanted areas of your level.</p>
<p>For consoles, 4K is more common because of the high adoption rate of 4K TVs. The Nintendo Switch offers 1280x720 resolution in handheld mode and up to 1920x1080 when connected to an external screen via HDMI.</p>
<p>As you can see, the resolution range can be very broad. If you are looking to support a particular device, this comprehensive <a href="https://en.wikipedia.org/wiki/List_of_common_resolutions">article</a> can help you find the proper target resolution.</p>
<p>To target full HD or 4K, keep a couple of best practices in mind (these rules don&#39;t apply to pixel art):</p>
<ul>
<li>Paint art in the highest resolution for your target devices</li>
<li>Stick to one resolution for all assets, and scale down later if necessary to support lower-end devices</li>
</ul>
<p>Don&#39;t scale up raster art because it can result in pixelation and blurriness, lowering visual quality. Always start from the highest resolution supported, then scale the art&#39;s resolution down when exporting from a graphics application. You&#39;ll find out more on how to do this in the section on <a href="#page-23-0">working between DCC</a>  <a href="#page-23-0">tools and Unity,</a> or you can try using <a href="#page-21-0">Variant Sprite Atlas</a> scaling.</p>
<p>One helpful trick is drawing your art at twice the size you need, then scaling it to 50% when you export to Unity. This technique will make your sprites look polished and crisp, and brush lines won&#39;t look so shaky. Don&#39;t overdo it on the details, since the art will be scaled down. This is a good trick for hiding the small imperfections resulting from hand-drawn art. Of course, if you want a handdrawn visual style for your game, then don&#39;t try this.</p>
<p>One you&#39;ve chosen the resolution, test the look of your art in the Game view to see how it will appear on target devices.</p>
<p>To keep it simple, calculate sprite resolution in Orthographic view instead of perspective. Set their scale to 1,1,1 and Z depth to 0 for easy visualization.</p>
<p><img src="_page_17_Picture_9.jpeg" alt=""></p>
<p>You can easily preview how the game looks at different ratios and resolutions in Game view.</p>
<p>Use the Unity grid and units to maintain consistent placement and appearance of your sprites, as well as to calculate camera zoom and object sizes.</p>
<p>A Unity unit is visualized by the grid in the Scene view. Assume that 1 Unity unit is equal to 1 meter. Set your base sizes first, and keep them consistent across your game.</p>
<p><img src="_page_18_Figure_2.jpeg" alt=""></p>
<p>Unity&#39;s Grid in the Scene View</p>
<p>Start with the size of your player character. Keep the height of the player character between 0.5 and 2 units. If you&#39;re using <a href="https://docs.unity3d.com/Manual/class-Tilemap.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Tilemap,</a> set the tile size to 1 unit.</p>
<p>Characters and objects that are too small or large compared to other visual elements in a game will lead to strange transform numbers and issues with physics calculations.</p>
<p>Once you&#39;ve established the sizes of your base objects in the main scene (Player character, enemies, collectibles, level hazards), choose your zoom level by setting the size property of the orthographic camera. After that, check the camera size value. When you multiply this value by 2, you&#39;ll get the camera vertical size in Unity units.</p>
<table>
<thead>
<tr>
<th>▼ ■ √ Camera</th>
<th></th>
<th></th>
<th>8 花</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Render Type</td>
<td>Base</td>
<td></td>
<td></td>
<td></td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>▼ Projection</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Projection</td>
<td>Orthographic</td>
<td></td>
<td></td>
<td></td>
<td>D</td>
<td></td>
</tr>
<tr>
<td>Size</td>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Clipping Planes</td>
<td>Near</td>
<td>0.3</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Far</td>
<td>1000</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>The size of the orthographic camera is expressed in units that express the vertical size of the camera from the center to the top.</p>
<p>If the camera size equals 5, its height is equal to 10 units. For example, if you target 4K resolution, then the screen (or camera) height is 2160 pixels. With a simple calculation, you can determine how many pixels per unit (PPU) your art needs:</p>
<h4 id="-2160-10-216-max-vertical-resolution-orthographic-camera-size-2-sprites-ppu-"><strong>2160 : 10 = 216 Max Vertical Resolution : (Orthographic Camera Size *2) = Sprites PPU</strong></h4>
<p>So every sprite in your game needs to have around 216 PPU to look good at a native 4K resolution.</p>
<p>That&#39;s a simple example. If you want your camera to zoom in and out, you&#39;ll need to account for that. If you set the maximum zoom percentage to size 3 in Orthographic view, the PPU needs to be 360 (2160 : (3 *2)).</p>
<table>
<thead>
<tr>
<th>O Inspector</th>
<th></th>
<th><br>a</th>
</tr>
</thead>
<tbody>
<tr>
<td>(48) 1999<br>Sprite_Barrel (Texture 2D) Import Settings</td>
<td></td>
<td>�花 :</td>
</tr>
<tr>
<td>1773</td>
<td></td>
<td>Open</td>
</tr>
<tr>
<td>Texture Type</td>
<td>Sprite (2D and UI)</td>
<td>V</td>
</tr>
<tr>
<td>Texture Shape</td>
<td>2D</td>
<td>D</td>
</tr>
<tr>
<td>Sprite Mode</td>
<td>Single</td>
<td>V</td>
</tr>
<tr>
<td>Packing Tag</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pixels Per Unit</td>
<td>216</td>
<td></td>
</tr>
<tr>
<td>Mesh Type</td>
<td>Tight</td>
<td></td>
</tr>
<tr>
<td>Extrude Edges</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pivot</td>
<td>Center</td>
<td>D</td>
</tr>
<tr>
<td>Generate Physics Shape</td>
<td>V</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Sprite Editor</td>
</tr>
</tbody>
</table>
<p>Setting the PPU for a sprite</p>
<p>If you&#39;re using skeletal animation, set the resolution of sprites slightly higher than the suggested PPU. Doing this is necessary because the meshes of the skeleton are rotated, stretched, and warped, sometimes to extremes, which can produce results that look bad. Aim for a lower resolution when the camera is zoomed in.</p>
<p><strong>Tip:</strong> When you set the PPU value of your game, apply a grid in your graphics software for reference. This is useful when using Tilemap because you will have the tile size in pixels and can to snap to a grid.</p>
<p><img src="_page_20_Picture_0.jpeg" alt=""></p>
<p>Setting the grid in Affinity Photo to match your game&#39;s PPU</p>
<p>You don&#39;t have to be strict with these numbers. Often, you can save memory by using a slightly lower sprite resolution than suggested. Cut out elements that aren&#39;t essential, such as background sprites.</p>
<p>Also, test your game on devices to check how it looks. In many cases, the benefits of using high-resolution assets aren&#39;t apparent. Instead, you can allocate this drawing time and device memory to other, more essential game elements like the main characters, visual effects, or UI. On mobile devices, game size is crucial, so check which assets can be scaled down and keep memory limitations in mind. Read more about 2D asset resolution in this <a href="https://blog.unity.com/technology/choosing-the-resolution-of-your-2d-art-assets?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">blog post.</a></p>
<h4 id="sprite-atlas">Sprite Atlas</h4>
<p>The Unity <a href="https://docs.unity3d.com/Manual/class-SpriteAtlas.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Sprite Atlas</a> feature has two main advantages.</p>
<p><strong>Pack multiple sprites into one texture to reduce draw calls:</strong> Each mesh with different materials or textures is drawn on the screen separately. Every sprite (which is a mesh) you put on the screen adds to the rendering time and can reduce a game&#39;s framerate.</p>
<p>Use Sprite Atlas to consolidate several Textures into a single, combined Texture. Unity can then call this single Texture to issue a single draw call instead of multiple ones. The packed Textures are accessed all at once, resulting in smaller performance overhead.</p>
<p><strong>Scale down sprites depending on device type:</strong> In Unity, it&#39;s efficient to scale an entire Sprite Atlas instead of individual sprites and assign the scaled atlas to different devices.</p>
<p>To build a new Sprite Atlas, right-click in the Project window (or select the Assets menu in the toolbar), and choose <strong>Create &gt; 2D &gt; Sprite Atlas</strong>. Be sure to give it a descriptive name. Then, in the Objects for Packing option, select the sprites you want to include, or include the entire folder. The Include in Build option should be checked by default. You now have your first Sprite Atlas.</p>
<p><img src="_page_21_Picture_0.jpeg" alt=""></p>
<p>A Sprite Atlas in Unity</p>
<h3 id="-span-id-page-21-0-span-variant-sprite-atlas"><span id="page-21-0"></span>Variant Sprite Atlas</h3>
<p>Use a <a href="https://docs.unity3d.com/Manual/MasterVariantAtlases.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Variant Sprite Atlas</a> to scale down sprites for specific devices. Create a Master Sprite Atlas as above, then change its Type to Variant in the Inspector (see the image below).</p>
<p>A Variant Sprite Atlas doesn&#39;t contain sprites itself. It relies on a Master Sprite Atlas, which you can choose in the Master Atlas field. Scale this atlas and all its sprites by choosing a value in the Scale Value field, between the range of 0.1 to 1.</p>
<table>
<thead>
<tr>
<th>0 Inspector</th>
<th></th>
<th>വ</th>
</tr>
</thead>
<tbody>
<tr>
<td>New Sprite Atlas (Sprite Atlas)</td>
<td></td>
<td>� 花</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Open</td>
</tr>
<tr>
<td>Type</td>
<td>Variant</td>
<td>œ</td>
</tr>
<tr>
<td>Master Atlas</td>
<td>到Environment</td>
<td>O</td>
</tr>
<tr>
<td>Include in Build</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Variant</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Scale</td>
<td>0.5</td>
<td></td>
</tr>
<tr>
<td>Texture</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Read/Write Enabled</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Generate Mip Maps</td>
<td></td>
<td></td>
</tr>
<tr>
<td>sRGB</td>
<td>V</td>
<td></td>
</tr>
<tr>
<td>Filter Mode</td>
<td>Bilinear</td>
<td></td>
</tr>
<tr>
<td>Show Platform Settings For</td>
<td>Main Texture<br>&gt;</td>
<td></td>
</tr>
<tr>
<td>Default<br>F</td>
<td>阅<br>iOS</td>
<td>டு</td>
</tr>
<tr>
<td>Format</td>
<td>Automatic</td>
<td>&gt;</td>
</tr>
<tr>
<td>Compression</td>
<td>Normal Quality</td>
<td>&gt;</td>
</tr>
<tr>
<td>Use Crunch Compression</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pack Preview</td>
<td></td>
</tr>
</tbody>
</table>
<p>Setting up a Variant Sprite Atlas</p>
<p>In a project that includes both a Master and a Variant Sprite Atlas, if both have the option Include in Build checked, the Texture used by mutual Sprites can come from either Sprite Atlas (refer to Scenario 3 in the <a href="https://docs.unity3d.com/Manual/SpriteAtlasScenarios.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Resolving different</a>  <a href="https://docs.unity3d.com/Manual/SpriteAtlasScenarios.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Sprite Atlas scenarios</a> section of Unity documentation).</p>
<p>To automatically load Sprite Textures from the Variant Atlas instead of the Master Atlas, enable Include in Build for the Variant Atlas only, and disable it for the Master Atlas. The build then automatically loads the Variant Sprite Atlas instead of the Master Atlas at runtime.</p>
<h2 id="drawing-in-vector-apps">Drawing in vector apps</h2>
<p>Art created in vector-based software such as Adobe Illustrator or Affinity Designer by Serif is not constrained by resolution. This is a significant advantage because you can change the size of your art assets at any time, without worrying about incorrect resolution settings.</p>
<p>You will still need to export your vector-based art to Unity as a PNG file. It&#39;s the same export workflow as that for raster or pixel art.</p>
<p><img src="_page_22_Picture_7.jpeg" alt=""></p>
<p>Vector art made in Affinity Designer – the left side of this illustration shows the vector view in the app, and the right shows the pixel view after export.</p>
<h2 id="-span-id-page-23-0-span-working-between-dcc-tools-and-unity"><span id="page-23-0"></span>Working between DCC tools and Unity</h2>
<p>You do a great deal of work on your art before moving it into Unity. You work hard to make all the characters, elements, props, and background art as beautiful and true to your vision as can be – so it&#39;s only natural that you want to get it all into Unity as quickly as possible.</p>
<p>Avoid exporting each layer one-by-one as a PNG file because this will take a long time. Instead, follow these tips for exporting your game sprites efficiently from different graphics software.</p>
<h4 id="-from-adobe-photoshop-"><strong>From Adobe Photoshop</strong></h4>
<p>Export and save layers as individual files using a variety of formats, including PSD, BMP, JPEG, PDF, Targa, and TIFF. Layers are automatically named as they are saved – set options to control the generation of names.</p>
<p>To export layers as files, do the following:</p>
<ul>
<li></li>
<li><ol>
<li>From the menu, select <strong>File &gt; Export &gt; Export Layers To Files</strong>.</li>
</ol>
</li>
</ul>
<p>Getting ready to export from Adobe Photoshop</p>
<ol>
<li>Under Destination, in the Export Layers To Files dialog box, click Browse to select a destination for the exported files. By default, the generated files are saved in the sample folder as the source file.</li>
</ol>
<table>
<thead>
<tr>
<th>Export Layers To Files</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Destination:</td>
<td></td>
</tr>
<tr>
<td>C:\Projects<br>Browse</td>
<td>Run</td>
</tr>
<tr>
<td>File Name Prefix:</td>
<td>Cancel</td>
</tr>
<tr>
<td>export_</td>
<td></td>
</tr>
<tr>
<td>Visible Layers Only</td>
<td></td>
</tr>
<tr>
<td>File Type:<br>PNG-24<br>&gt;</td>
<td></td>
</tr>
<tr>
<td>Include ICC Profile</td>
<td></td>
</tr>
<tr>
<td>PNG-24 Options:</td>
<td></td>
</tr>
<tr>
<td>Transparency Interlaced V Trim Layers</td>
<td></td>
</tr>
<tr>
<td>Please specify the format and location for saving each layer as a file.</td>
<td></td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>The Export Layers to Files dialog box</p>
<ul>
<li><ol>
<li>If you want your sprites to have a common file name prefix, enter it in the text field–for example, tile_wood01.png, tile_bricks01.png, and so on.</li>
</ol>
</li>
<li><ol>
<li>To export the layers only visible in the Layers panel, select Visible Layers Only.</li>
</ol>
</li>
<li><ol>
<li>Choose PNG-24 as a File Type. You don&#39;t need to include an ICC profile, so uncheck that.</li>
</ol>
</li>
<li><ol>
<li>Check the Transparency and Trim Layers options in the PNG options section, and uncheck Interlaced.</li>
</ol>
</li>
<li><ol>
<li>Click Run, and after a short wait, the sprites should export to the folder you specified.</li>
</ol>
</li>
<li><ol>
<li>Use these steps to export a limited amount of layers quickly. Note that all layers are exported separately. This method does not take layer groups into account, so if you have a character or object that consists of multiple layers, merge them before exporting.</li>
</ol>
</li>
</ul>
<p>Let&#39;s look at <a href="https://helpx.adobe.com/photoshop/using/generate-assets-layers.html">how</a> to export sprites with multiple layers from Photoshop. It requires more setup, but this approach allows greater control over the exported images.</p>
<p>To start, you&#39;ll need the names of the layers or layer groups from which you want to generate sprites. For example, the image below shows a sprite of a barrel consisting of a normal map and mask map. Each sprite is in a separate folder that has been saved as a PNG file.</p>
<p><img src="_page_25_Picture_0.jpeg" alt=""></p>
<p>A sprite with both a normal map and a mask map</p>
<p>Select <strong>File &gt; Generate &gt; Image Assets</strong> from the menu. Photoshop will create a folder as a PSD file and export all the layers or groups saved as PNG files. If you haven&#39;t saved a PSD file yet, it will create a folder on your desktop.</p>
<p>A benefit of this method is that if you change any layer or folder which is marked for export, the image asset will be exported in the background automatically.</p>
<p>Specify the folder for every sprite by adding its name and a slash before the layer name. In this case, to group all three barrel sprites into one folder, you would add &quot;barrel/&quot; before the layer names.</p>
<p><img src="_page_25_Picture_5.jpeg" alt=""></p>
<p>Exporting multiple layers of the same sprite from Photoshop</p>
<p>To change the sprite&#39;s size, add the specified dimensions or scale in percent before the layer name, for example, &quot;50% barrel/barrel.png&quot; or &quot;80 x 160 barrel/ barrel.png&quot;. When specifying dimensions, Photoshop will use pixels as the default unit.</p>
<h4 id="-exporting-from-affinity-photo-or-affinity-designer-"><strong>Exporting from Affinity Photo or Affinity Designer</strong></h4>
<p>Both Affinity Photo and Affinity Designer provide a dedicated mode for exporting, called <a href="https://www.creativebloq.com/how-to/affinity-designer-how-to-use-the-export-persona">Export Persona</a>. Let&#39;s go through the steps for using it.</p>
<p>Switch to Export Persona by clicking its icon in the top left of the application toolbar, as seen in the image below.</p>
<p><img src="_page_26_Picture_3.jpeg" alt=""></p>
<p>Export Persona in Affinity Photo</p>
<p>To export a sprite, create a slice from a layer or layer group. Switch to the Layers tab on the right, select a layer to export, and click the Create Slice button.</p>
<p>Switch to the Slices tab, select the slices to export, and be sure that the Export preset is set to Single PNG for all the slices, as seen in the following image.</p>
<p><img src="_page_26_Picture_7.jpeg" alt=""></p>
<p>Set the Export present to Single PNG in Affinity Photo</p>
<p>Click Export Slice, and choose a destination folder when prompted. You can save time by exporting the sprites directly to the Assets folder in your Unity project.</p>
<p>After choosing a destination folder, the Continuous option becomes available, which allows you to export slices whenever you change a layer.</p>
<p>To have better control over the exported sprites, set the export options manually for every splice by clicking the arrow icon to the left of the slice name.</p>
<p><img src="_page_27_Picture_3.jpeg" alt=""></p>
<p>Setting export options for sprites</p>
<p>Choose a subfolder for your sprite in the Path section. In this example, all of the barrel sprites are in the &quot;barrel&quot; subfolder. PNG is the file format, and resolution scaling is set at 1x, which means no scaling, so the sprites are exported at 100% their size. You can also output multiple sizes at once by clicking the &quot;+&quot; button.</p>
<p>For multiplatform games, choose additional sizes for your sprites that can be used when building your project for other devices. For example, choose 2x for scaling to get &quot;Retina&quot; sprites.</p>
<p>Another &quot;+&quot; button on the bottom of the expanded window allows you to add additional file formats if you want to export JPG files alongside the PNG sprites.</p>
<table>
<thead>
<tr>
<th>II Export Options<br>, x</th>
<th>Export Layers - Krita</th>
<th>×</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mode: Selection Defaults<br>Preset:</td>
<td>Documents:</td>
<td>C:/Projects/normalmap_v6.psd</td>
</tr>
<tr>
<td>File format:<br>PNG</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pixel format: Use document format</td>
<td></td>
<td>Refresh</td>
</tr>
<tr>
<td>Resampler:<br>Bilinear<br>Matte:</td>
<td>Initial directory:</td>
<td>C:/Projects/Export</td>
</tr>
<tr>
<td></td>
<td>Export options:</td>
<td>Export filter layers</td>
</tr>
<tr>
<td>ICC Profile:</td>
<td></td>
<td>V Export in batchmode</td>
</tr>
<tr>
<td>Embed ICC profile</td>
<td></td>
<td>V<br>Group as layer</td>
</tr>
<tr>
<td>Include bleed</td>
<td></td>
<td>V Ignore invisible layers</td>
</tr>
<tr>
<td>Palettised</td>
<td></td>
<td>V Adjust export size to layer content</td>
</tr>
<tr>
<td>Palette:</td>
<td>Export size:</td>
<td>- dpi: 72<br>- 1080<br>1920</td>
</tr>
<tr>
<td>Colours:</td>
<td>Images extensions:</td>
<td>PNG<br>A</td>
</tr>
<tr>
<td>Embed metadata</td>
<td></td>
<td>OK<br>Cancel</td>
</tr>
</tbody>
</table>
<p>Export Options window in Affinity apps Exporting sprites from Krita</p>
<h4 id="-exporting-from-krita-"><strong>Exporting from Krita</strong></h4>
<p>Be sure to save your document, and select <strong>Tools &gt; Scripts &gt; Export Layers.</strong> In the pop-up window, select the Initial directory. This will be where sprite files are exported.</p>
<p>In Export options, check the Adjust export size option to layer content. This will crop layers to their size, leaving no empty pixels padding. There are a couple of optional settings:</p>
<ul>
<li>Group as layer: This option will export groups rather than individual layers, a good choice for when your sprites consist of multiple layers. Note that the exporter will only check for the highest groups in the hierarchy, so your sprites cannot be grouped in another group.</li>
<li>Ignore invisible layers: This is handy when you want to exclude some sprites from exporting by turning off their visibility.</li>
</ul>
<p>Choose PNG as Image extensions, click OK, and the sprites will be exported to the your selected folder.</p>
<h2 id="import-photoshop-psd-files-into-unity">Import Photoshop PSD files into Unity</h2>
<p>Exporting to PNG file format is the most convenient workflow for sprites, but you can also import PSD files directly into Unity. By default, this will flatten the PSD layers into one image.</p>
<p>This method is convenient to use for background art sprites. Edit and paint layers, and, when you save the file, the changes will be instantly visible in the Editor. Then you will have your PSD source file directly in the Unity project, and the file can be included in source control.</p>
<p>Unity&#39;s <a href="https://docs.unity3d.com/Packages/com.unity.2d.psdimporter@4.1/manual/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">2D PSD Importer</a> package gives you the option of importing layers as separate sprites. This package was designed for use with 2D animation, but you can use it to import multiple regular sprites contained in one PSD file. You can also make frame-by-frame animations. Find more on how to use this package in the <a href="#page-53-0">2D Animation</a> section or <a href="https://blog.unity.com/technology/how-to-speed-up-2d-art-workflows-with-2d-psd-importer?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">this</a> blog post.</p>
<p><img src="_page_29_Picture_4.jpeg" alt=""></p>
<p>A multi-layer Photoshop file imported in Unity</p>
<h2 id="-span-id-page-30-0-span-level-design-"><span id="page-30-0"></span><strong>Level design</strong></h2>
<p>There are many ways to prototype levels, so choose the methods that suit your creative style and workflow best.</p>
<p>Sketching out ideas on paper will probably always be popular because it&#39;s simple, direct, portable, and cheap. In the early days, it was also a necessity to communicate the placement of tiles and game elements to the team.</p>
<p><img src="_page_30_Picture_3.jpeg" alt=""></p>
<p>Modern games like <em>Hollow Knight</em> use paper for level design and art concept. See the process in this Rockpapershotgun <a href="https://www.rockpapershotgun.com/hollow-knight-concept-art">article</a> </p>
<p>This was the best way to design levels for many years, and it&#39;s still very useful. However, now you can test ideas earlier and more vigorously by sketching them out in Unity. Let&#39;s look at the tools available.</p>
<h2 id="white-boxing">White boxing</h2>
<p>White boxing, a well-known term from 3D level design, involves placing plain white cubes to test out level design ideas quickly. The reason designers white box is to map out ideas for game flow without any distracting details.</p>
<p>This method can also be applied to 2D graphics by using 2D geometric figures or other prototyping tools.</p>
<p>In white boxing, the focus should be on only the things the player will interact with, such as the ground, enemies, level hazards, and pickups. All of these things can be made from the simplest forms, then color-coded to distinguish between them more easily. For example, enemies and other hazards could be colored red, pickups green, switches blue, and so on.</p>
<p>Start with the collision/interaction layer, which includes the ground, walls, and platforms that the player jumps on.</p>
<h4 id="-span-id-page-31-0-span-white-boxing-with-basic-sprites-"><span id="page-31-0"></span><strong>White boxing with basic sprites</strong></h4>
<p>Start with the default 2D assets available in Unity, which come in simple geometric shapes.</p>
<p>Right-click in the Project window (or click on the Assets menu in the toolbar), and choose <strong>Assets &gt; Create &gt; 2D &gt; Sprites.</strong> All of the shapes come with predefined collision shapes, so you only need to add a Polygon Collider 2D component to a sprite shape to make it be affected by gravity or collisions.</p>
<p><img src="_page_31_Picture_3.jpeg" alt=""></p>
<p>All the sprites available in the Sprite Creator</p>
<p>The selected sprites will be created in the folder that&#39;s currently opened in the Project window.</p>
<p>Use different shapes for different purposes. For example, use a capsule for your player, circles for pickups, hexagons for enemies, and squares for the ground or walls. Tint each category of sprite a different color with the color property available in the Sprite Renderer.</p>
<p>For sprites to use 2D Physics collisions, add a corresponding Collider 2D component that will match the object&#39;s overall shape along with a 2D Rigidbody. Choose the Dynamic body type for the Rigidbody to react to gravity, forces, or collision.</p>
<p>For precise placement, snap the sprites to the grid by holding down Ctrl as you move them. This will move them in 0.25-unit increments.</p>
<h2 id="2d-sprite-shape">2D Sprite Shape</h2>
<p><a href="https://docs.unity3d.com/Packages/com.unity.2d.spriteshape@5.1/manual/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">2D Sprite Shape</a> is a tool that allows you to create paths and tile sprites along them. These paths work similarly to the well-known pen tool used in graphics software. They are Bézier curves that can be edited directly in the scene and optionally closed and filled with tiling texture.</p>
<p><img src="_page_32_Picture_2.jpeg" alt=""></p>
<p>Linear and Continuous Sprite Shape objects</p>
<p>Sprite Shape is a handy prototyping feature in Unity because it makes it efficient to create and edit new sprite shapes.</p>
<p>If you choose to create your 2D project with the 2D Template, then Sprite Shape is installed by default. Otherwise, you can install it using the Package Manager.</p>
<table>
<thead>
<tr>
<th></th>
<th>File Edit Assets GameObject Component Window Help</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>3<br>← →<br>0</td>
<td>Create Empty</td>
<td>Ctrl+Shift+N</td>
<td>书</td>
<td></td>
</tr>
<tr>
<td>E Hierarchy</td>
<td>Create Empty Child</td>
<td>Alt+Shift+N</td>
<td>a<br></td>
<td># Scene</td>
</tr>
<tr>
<td>+ ▼</td>
<td>Create Empty Parent</td>
<td>Ctrl+Shift+G</td>
<td></td>
<td>Shaded</td>
</tr>
<tr>
<td>V &amp; Place</td>
<td>2D Object</td>
<td>&gt;</td>
<td>Sprites</td>
<td>&gt;</td>
</tr>
<tr>
<td>Mai</td>
<td>3D Object</td>
<td>&gt;</td>
<td>Physics</td>
<td>&gt;</td>
</tr>
<tr>
<td>G Squ</td>
<td>Effects</td>
<td>&gt;</td>
<td>Tilemap</td>
<td>&gt;</td>
</tr>
<tr>
<td>Circ<br>Cap</td>
<td>Light</td>
<td>&gt;</td>
<td>Sprite Shape</td>
<td>&gt;</td>
</tr>
<tr>
<td>Sisor</td>
<td>Audio</td>
<td>&gt;</td>
<td>Pixel Perfect Camera</td>
<td></td>
</tr>
<tr>
<td>CHex</td>
<td>Video</td>
<td>&gt;</td>
<td>Sprite Mask</td>
<td></td>
</tr>
<tr>
<td>GHex<br>89-5</td>
<td>UI</td>
<td>&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>GGIO</td>
<td>Volume</td>
<td>&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Clos</td>
<td>Camera</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Clo</td>
<td>Center On Children</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Make Parent</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Clear Parent</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Set as first sibling</td>
<td>Ctr +=</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Set as last sibling</td>
<td>Ctr +-</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Move To View</td>
<td>Ctr + Alt + F</td>
<td></td>
</tr>
</tbody>
</table>
<p>To make a new Sprite Shape, click on the GameObject menu, <strong>2D Object &gt; Sprite Shape,</strong> and select either Open or Closed Shape.</p>
<p>Creating a Sprite Shape</p>
<p>To modify the Sprite Shape, select it, then click the Edit button in the Inspector.</p>
<table>
<thead>
<tr>
<th>T &amp; Sprite Shape Controller (Script)</th>
<th></th>
<th>9<br>2</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Profile</td>
<td>Sprite Shape Profile (Sprite Shape)<br>8<br>Edit Spline</td>
<td></td>
<td>O</td>
</tr>
<tr>
<td>Tangent Mode</td>
<td>8<br>8<br>8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Position</td>
<td>Y 2.78<br>X 10.76</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Height</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Corner</td>
<td>Automatic</td>
<td></td>
<td>œ</td>
</tr>
<tr>
<td>Sprite Variant</td>
<td>O</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Snapping</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Spline</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Detail</td>
<td>High Quality</td>
<td></td>
<td>œ</td>
</tr>
<tr>
<td>Is Open Ended</td>
<td>ﺍﻟﻤﺴﺎﻋﺪ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘ</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Adaptive UV</td>
<td>&lt; &lt; &lt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Optimize Geometry</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Enable Tangents</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cache Geometry</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Corner Threshold</td>
<td></td>
<td>30</td>
<td></td>
</tr>
<tr>
<td>Fill</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fill Tessellation (C# Job)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Stretch UV</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pixel Per Unit</td>
<td>256</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Worldspace UV</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Modifying a Sprite Shape in the Inspector window</p>
<p>Left-click on any part of the Sprite Shape to add or delete points with the delete key. By selecting a point, you can change its mode by selecting one of the three Tangent Mode buttons:</p>
<ul>
<li><strong>Linear:</strong> Creates no curve, with straight lines on both sides of the points</li>
<li><strong>Continuous:</strong> Creates a curve around the point with handles that face opposite directions</li>
<li><strong>Broken:</strong> Creates a curve around the point with handles that can move independently</li>
</ul>
<p>You can also select how the corners around the points look. The snapping tool is another useful option that snaps the points to the grid.</p>
<p>Add a Polygon Collider 2D Component for physics. The default properties should be sufficient for prototyping purposes.</p>
<table>
<thead>
<tr>
<th>T &amp; Sprite Shape Controller (Script)</th>
<th></th>
<th>2</th>
<th>2</th>
<th>:</th>
</tr>
</thead>
<tbody>
<tr>
<td>Profile</td>
<td>Sprite Shape Profile (Sprite Shape)</td>
<td></td>
<td></td>
<td>O</td>
</tr>
<tr>
<td></td>
<td>r.<br>Edit Spline</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Spline</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Detail</td>
<td>High Quality</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Is Open Ended</td>
<td>1-1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Adaptive UV</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Optimize Geometry</td>
<td>V</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Enable Tangents</td>
<td>&gt;</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Corner Threshold</td>
<td></td>
<td>30</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fill</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fill Tessellation (C# Job)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Stretch UV</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pixel Per Unit</td>
<td>256</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Worldspace UV</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Collider</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Update Collider</td>
<td>&gt;</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Offset</td>
<td></td>
<td>0 0.5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Optimize Collider</td>
<td>V</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Detail</td>
<td>High Quality</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>▼ 4 + Polygon Collider 2D</td>
<td></td>
<td>9 花</td>
<td></td>
<td>:</td>
</tr>
<tr>
<td>Edit Collider</td>
<td>80</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Material</td>
<td>None (Physics Material 2D)</td>
<td></td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>Is Trigger</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Used By Effector</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Used By Composite</td>
<td>000</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Auto Tiling</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Offset<br>Points</td>
<td>× 0<br>Y O</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>▶ Info</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Adding a Polygon Collider 2D Component</p>
<p>By following these steps, you can create Sprite Shapes that can interact with one another and be easily modified through their Inspectors.</p>
<h4 id="tilemaps">Tilemaps</h4>
<p>The <a href="https://docs.unity3d.com/Manual/class-Tilemap.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Tilemap</a> feature is great for quick prototyping. Tilemap offers a way to create a game world using small sprites, called tiles, placed on a grid. Instead of laying out a game world that is one big image, you can split it into brick-like chunks that are repeated through a whole level.</p>
<p>Tilemaps can help save on memory and CPU power because tiles that are not visible on the screen can be disabled. A brush tool makes it efficient to paint them on a grid, and they can also be scripted to use some painting rules. They come with automatic collision generation for efficient testing and editing.</p>
<p><img src="_page_35_Figure_0.jpeg" alt=""></p>
<p>A visual representation of the background and sprite tiles of a retro 8-bit game that are loaded into VRAM. The console cleanly keeps backgrounds and sprites loaded on separate pages.</p>
<p>The 2D Tilemap Editor is installed with the 2D Project Template or from the Package Manager.</p>
<p>Installing the <a href="https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@1.8/manual/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">2D Tilemap Extras</a> package provides reusable 2D and Tilemap editor scripts that you can use for your own projects, and these can also serve as a base for creating custom brushes and tiles. Get the package by enabling Preview Packages in Project Settings (<strong>Edit &gt; Project Settings</strong>). In the Package Manager, turn on the Enable Preview Packages option located in the Advanced Settings box.</p>
<p><img src="_page_35_Picture_4.jpeg" alt=""></p>
<p>View Preview Packages in the Package Manager</p>
<p>Install samples, along with the 2D Tilemap Extras to see examples using the scripts that come with the package. You can read more about the <a href="https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@1.8/manual/Brushes.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Scriptable Brushes</a> and <a href="https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@1.8/manual/Tiles.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Scriptable Tiles</a> included in the package in the Unity documentation.</p>
<p>Once both packages are installed, open the Tile Palette window via <strong>Window &gt; 2D &gt; Tile Palette</strong>.</p>
<p><img src="_page_36_Figure_2.jpeg" alt=""></p>
<p>This window will hold all the tiles and tools to help you paint or edit Tilemaps.</p>
<p>Tile Palette window with a palette loaded</p>
<p>Create a new Palette by clicking the Create New Palette button. A dropdown window with options will appear. Give the palette a name, set its options, click Create, and save it to a selected folder.</p>
<table>
<thead>
<tr>
<th>Create New Palette</th>
<th></th>
<th>&gt;</th>
<th>Edit</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Create New Palette</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Name</td>
<td>New Palette</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Grid</td>
<td>Rectangle</td>
<td></td>
<td></td>
<td></td>
<td>V</td>
<td></td>
</tr>
<tr>
<td>Cell Size</td>
<td>Automatic</td>
<td></td>
<td></td>
<td></td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>× 1</td>
<td>Y 1</td>
<td></td>
<td>ZO</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Sort Mode</td>
<td>Default</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Sort Axis</td>
<td>X 0</td>
<td>YO YO</td>
<td></td>
<td>Z 1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cancel</td>
<td></td>
<td></td>
<td>Create</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Creating a new palette</p>
<p>Now, add tiles to the palette. Drag a sprite, texture, or Tile Asset into the Palette window. Use one of the simple Sprite Shapes you created earlier, and place it in the empty part of the window. Choose a file in which to create the asset. You should now see your sprite in the grid of the palette.</p>
<p><img src="_page_37_Figure_1.jpeg" alt=""></p>
<p>Dragging a sprite into a palette creates a new tile.</p>
<p>Now, create a Tilemap to paint the tiles. Click the menu item <strong>Gameobject &gt; 2D Object &gt; Tilemap &gt; Rectangular</strong>.</p>
<p><img src="_page_37_Figure_4.jpeg" alt=""></p>
<p>Creating a Tilemap</p>
<p>You have created a Grid and a Tilemap within it. Rename the Tilemap to something more descriptive. The Grid can hold multiple Tilemaps, and it&#39;s possible to have multiple Grids per scene, for example, with different cell sizes. For now, leave all the default settings of the Grid component.</p>
<p>The Tilemap GameObject has two components: Tilemap and Tilemap Renderer. Leave the settings as they are. If you need to, change the Sorting Layer settings to fit your layer structure.</p>
<table>
<thead>
<tr>
<th>Tilemap<br>V</th>
<th></th>
<th></th>
<th></th>
<th>北<br>?</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Animation Frame Rate</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Color</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>00</td>
</tr>
<tr>
<td>Tile Anchor</td>
<td>× 0.5</td>
<td>Y 0.5</td>
<td>Z O</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Orientation</td>
<td>XY</td>
<td></td>
<td></td>
<td></td>
<td>&gt;</td>
</tr>
<tr>
<td>Offset</td>
<td>X 0</td>
<td>Y O</td>
<td>Z<br>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Rotation</td>
<td>X 0</td>
<td>Y O</td>
<td>Z<br>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Scale</td>
<td>× 1</td>
<td>Y 1</td>
<td>Z 1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>J / Tilemap Renderer<br>&gt;</td>
<td></td>
<td></td>
<td></td>
<td>2<br>2</td>
<td></td>
</tr>
<tr>
<td>Sort Order</td>
<td>Bottom Left</td>
<td></td>
<td></td>
<td></td>
<td>D</td>
</tr>
<tr>
<td>Mode</td>
<td>Chunk</td>
<td></td>
<td></td>
<td></td>
<td>œ</td>
</tr>
<tr>
<td>Detect Chunk Culling Bounds</td>
<td>Auto</td>
<td></td>
<td></td>
<td></td>
<td>D</td>
</tr>
<tr>
<td>Chunk Culling Bounds</td>
<td>X 0</td>
<td>Y O</td>
<td>ZO</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mask Interaction</td>
<td>None</td>
<td></td>
<td></td>
<td></td>
<td>&gt;</td>
</tr>
<tr>
<td>Material</td>
<td>· Sprite-Lit-Default</td>
<td></td>
<td></td>
<td></td>
<td>O</td>
</tr>
<tr>
<td>Additional Settings<br>&gt;</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Sorting Layer</td>
<td>Default</td>
<td></td>
<td></td>
<td></td>
<td>œ</td>
</tr>
<tr>
<td>Order in Layer</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Rendering Layer Mask</td>
<td>Layer1</td>
<td></td>
<td></td>
<td></td>
<td>D</td>
</tr>
</tbody>
</table>
<p>Tilemap and Tilemap Renderer components</p>
<p>With your Tilemap and Tile on a palette, you are ready to start painting. Click on the brush tool in the Palette window toolbar, and select a tile to paint.</p>
<p><img src="_page_38_Figure_5.jpeg" alt=""></p>
<p>Tilemap with painted placeholder tiles</p>
<p>Next, you can create a prototype for a level. Add a Tilemap Collider 2D to the Tilemap for physics. This will add colliders to each of the tiles based on the collider type set in the Tile Asset.</p>
<p>Add a Composite Collider 2D to combine the colliders into one, resulting in smoother collision behavior with geometry set as Outline. The tiles will behave like a continuous terrain rather than as individual tiles. This setup also brings a slight performance boost. However, if you plan for your game to add or remove tiles at runtime, you might want to keep a collider on each tile.</p>
<p>Remember to check the Used by Composite option on the Collider 2D component, and set the Rigidbody 2D Type to static so it doesn&#39;t fall.</p>
<table>
<thead>
<tr>
<th>C<br>Rigidbody 2D<br>2</th>
<th></th>
<th>?)</th>
<th>14</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Body Type</td>
<td>Static</td>
<td></td>
<td></td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Material</td>
<td>None (Physics Material 2D)</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>Simulated</td>
<td>&gt;</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Info<br>A</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>▼ Tilemap Collider 2D</td>
<td></td>
<td>2</td>
<td>20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Max Tile Change Count 1000</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Extrusion Factor</td>
<td>1e-05</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Used By Composite</td>
<td>V</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Offset</td>
<td>X 0<br>Y O</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Info<br>A</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>O<br>D<br>Composite Collider 2D</td>
<td></td>
<td>0</td>
<td>14</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Material</td>
<td>None (Physics Material 2D)</td>
<td></td>
<td></td>
<td>O</td>
<td></td>
</tr>
<tr>
<td>Is Trigger</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Used By Effector</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Offset</td>
<td>Y O<br>X 0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Geometry Type</td>
<td>Outlines</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Generation Type</td>
<td>Synchronous</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Vertex Distance</td>
<td>0.0005</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Offset Distance</td>
<td>5e-05</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Edge Radius</td>
<td>O</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&gt; Info</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Collider 2D component on a Tilemap GameObject</p>
<p>Let&#39;s look at the different Palette tools (the keyboard shortcuts are noted in brackets).</p>
<p><img src="_page_40_Picture_1.jpeg" alt=""></p>
<p>Tile Palette tools</p>
<ul>
<li><strong>Selection (S)</strong>: Click to select one tile, or drag to select tiles within a rectangular area.</li>
<li><strong>Move (M)</strong>: Move the selected tiles.</li>
<li><strong>Brush (B)</strong>: Paint on an Active Tilemap (select one from the Active Tilemap dropdown) with the selected tile and brush.</li>
<li><strong>Fill Selection (U)</strong>: Drag to fill a rectangular area using a selected tile.</li>
<li><strong>Tile Sampler (I)</strong>: Pick a tile from a Tilemap, and set it as active to paint.</li>
<li><strong>Eraser (D)</strong>: Delete tiles from a Tilemap.</li>
<li><strong>Fill (G)</strong>: Fill an area with a tile (the area needs to be bordered with other tiles).</li>
</ul>
<p>With these tools alone, you can paint and edit tiles efficiently. Additionally, the Tilemap Extras Asset provides useful scripts such as Rule Tile.</p>
<h2 id="rule-tile">Rule Tile</h2>
<p>This is a scripted tile that recognizes its surroundings and selects the appropriate image, for example, a ground tile with grass on top and a shadow on the bottom.</p>
<p>The 2D Tilemap Extras package comes with a Dungeon Rule Tile sample located in <strong>Assets &gt; Samples &gt; 2D Tilemaps Extras &gt; &quot;version number&quot; &gt; Dungeon Rule Tile &gt; Tiles</strong>. Drag it onto the Tile Palette to start painting.</p>
<p>Rule Tile automatically recognizes where adjacent tiles are and where there should be borders. It chooses the proper sprite for you, so you don&#39;t have to select different tiles to paint the borders.</p>
<p><img src="_page_40_Picture_15.jpeg" alt=""></p>
<p>Painting Tilemaps</p>
<p><img src="_page_41_Picture_0.jpeg" alt=""></p>
<p>The Rule Tile asset in the Inspector</p>
<p>The Rule Tile Inspector provides a list of rules for which sprite to choose based on the adjacent tiles. There&#39;s a matrix and a sprite on the right side of each rule. The sprite will be used when neighbor tiles are on all sides where the green arrows are pointing.</p>
<p>Learn more about the Rule Tile feature <a href="https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@1.6/manual/RuleTile.html">here.</a></p>
<p>This is just one example of how to use the Rule Tile. You can also replace the sprites that come with this sample or create a new Rule Tile that matches your game&#39;s needs.</p>
<p>You can find ready-made Tilemap templates that are available from the community and the Asset Store. A few good ones to check out include <a href="https://pandaroo.itch.io/tilemap-auto-rule-tile-unity-template">TileMap</a>  <a href="https://pandaroo.itch.io/tilemap-auto-rule-tile-unity-template">Auto Rule</a> by Pandaroo, <a href="https://assetstore.unity.com/packages/3d/environments/2d-pixelart-isometric-blocks-115039">2D PixelArt – Isometric Blocks</a> by Devil&#39;s Work.shop, and both <a href="https://assetstore.unity.com/packages/2d/environments/pixel-art-platformer-village-props-166114">Pixel Art Platformer</a> and <a href="https://assetstore.unity.com/packages/2d/environments/pixel-art-top-down-basic-187605#content">Pixel Art Top Down</a> by Cainos.</p>
<p>Learn more about Tilemap best practices in <a href="https://www.youtube.com/watch?v=rKlvgkDHWfQ?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">this</a> video, and optimizing Tilemap performance in <a href="https://unity.com/how-to/optimize-performance-2d-games-unity-tilemap?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">this</a> article.</p>
<h2 id="sprite-shape-level-design">Sprite Shape level design</h2>
<p>Grid or tile-based design is well-suited to a retro 2D visual style, especially when you&#39;re using pixel art. It&#39;s also great for side-scrolling horizontal platformers, topdown RPGs, and non-organic shapes such as buildings and castles.</p>
<p>The grid-based design makes pathfinding and level creation more straightforward. Pathfinding is simpler when constrained to a grid. It makes it easier to maintain constant distances when you&#39;re designing levels. If your character&#39;s jump is 3 units high, for example, you can easily plan where to put platforms, and the player will be able to estimate if he can make the jump or not instantly.</p>
<p>Individual tiles can be animated, for example by adding a waterfall, burning torch, spinning fan, and so on. You can make slopes with Tilemaps, but they will be straight surfaces with angles like 45 or 26.5 degrees.</p>
<p>When you want a more organic, less block-based style, use <a href="https://docs.unity3d.com/Packages/com.unity.2d.spriteshape@5.1/manual/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">2D Sprite Shape</a>. With this setup, you&#39;re not constrained to a grid or particular angle. You can make any shape you want using curves. Terrains, hills, grassy fields, and smooth surfaces are all suited to Sprite Shape, which lends a modern look to your scenes compared to the crisper pixel-art style.</p>
<p>Turn on the snapping tool to set any angle or curve easily and place elements precisely.</p>
<p><img src="_page_42_Picture_6.jpeg" alt=""></p>
<p>On the left, <em>Skul: The Hero Slayer,</em> by SouthPAW Games is a Tilemap-based game, while <em>Oddmar</em>, by Mobge LTD on the right, is a spline-based game.</p>
<p>Levels and elements created with Tilemaps or Sprite Shapes are easy to edit later. Depending on your visual style, you can use both systems in your game.</p>
<p>Both Tilemaps and Sprite Shapes can be modified during runtime to create exciting new gameplay possibilities. For example, Tilemaps can be destructive, and Sprite Shape can be morphed – the possibilities are endless. Read more about the options in the <a href="https://docs.unity3d.com/ScriptReference/Tilemaps.Tilemap.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Tilemap API</a> and <a href="https://docs.unity3d.com/ScriptReference/U2D.SpriteShapeRenderer.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">SpriteShape API</a> docs.</p>
<h2 id="orthographic-or-perspective-camera">Orthographic or Perspective Camera</h2>
<p>For most 2D games, you&#39;ll want to set your camera to orthographic mode. It&#39;s the default choice for 2D projects because lines of one dimension are parallel, and you work only in two dimensions. The orthographic mode works for all styles – pixel art games, puzzles, 2D isometric, top-down, platformers.</p>
<p>Although 2D games have no real depth, the illusion of depth can be created using the parallax effect. The parallax effect scrolls multiple layers in the background and foreground at different speeds when the camera moves. The intent is to mimic human depth perception, wherein objects farther away appear to move more slowly than those closer to us.</p>
<p>In 2D, this is usually done with a script that moves layers with a percentage of camera movement speed. It requires some manual setup to adjust the speed of each parallax layer.</p>
<p><img src="_page_43_Picture_4.jpeg" alt=""></p>
<p>Perspective camera setup in <em><a href="https://store.steampowered.com/app/1283410/Tails_of_Iron/">Tails of Iron</a></em> By Oddbug Studio. Learn how they created the lighting in their game with Unity.</p>
<p>If orthographic mode is suitable for all 2D game styles, why even use perspective mode?</p>
<p>One reason is that this offers access to parallax effects out of the box since, as the name suggests, a Perspective camera uses a perspective viewpoint. You don&#39;t need to use scripts to handle the scrolling of parallax layers. Instead, you position elements further from the camera on the Z axis and scale them up to account for perspective based on their relative distance from the camera.</p>
<p>Parallaxed sprites don&#39;t move with the camera every frame, so background objects can be marked as static for batching. Adding some 3D objects into your scene can provide more depth as well.</p>
<p>Orthographic mode with scripted parallax effects requires you to set up the scrolling speeds on all layers manually. The depth effect can break if layers have incorrect scrolling speeds, and editing a parallax level requires additional coding.</p>
<p>Suppose you&#39;re making a <em>Metroidvania</em>-style game with scenes that include multiple points of entry. In this case, the parallax effect can break because the camera can start at a different position on the X axis than where you edited parallax elements.</p>
<p>Once it&#39;s set up, the Perspective camera will work for parallax effects. The only downside is that you need to scale sprites as you move them along the Z axis. Also, approach allows the scene to be split into smaller scenes for <a href="https://blog.unity.com/technology/achieve-better-scene-workflow-with-scriptableobjects?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">additive</a>  <a href="https://blog.unity.com/technology/achieve-better-scene-workflow-with-scriptableobjects?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">loading,</a> like a room system that allows for dynamic world loading.</p>
<p>The camera you choose doesn&#39;t impact the art creation process, but it does determine how the levels are set up. And, if they&#39;re set up correctly, orthographic and perspective parallax will look the same to the player.</p>
<p>To sum up, an orthographic mode is the best choice in most cases, except when you&#39;re using advanced scrolling and parallax. In that case, go with perspective mode.</p>
<p><img src="_page_44_Picture_6.jpeg" alt=""></p>
<p>Orthographic mode camera in <em>Dragon Crashers</em></p>
<h2 id="mixing-2d-and-3d">Mixing 2D and 3D</h2>
<p>If your project uses the Built-In Render Pipeline or the Universal Render Pipeline (URP), it&#39;s easy to mix 2D and 3D elements in the same Scene. 2D Rendering uses <a href="https://docs.unity3d.com/Manual/2DSorting.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-artist-expansion&amp;utm_content=technical-artist-ebook">Sorting Layers</a> and <a href="https://docs.unity3d.com/Manual/2DSorting.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Sorting Groups</a> to define the order for rendering game elements. Adding the Sorting Group component to a 3D GameObject allows you to easily integrate 3D and 2D objects into the same game. You can have them interact with one another by using a common physics system (either 2D or 3D Physics, depending on the best approach for the game) and mixing 2D and 3D lighting systems through the Camera Stacking feature in URP.</p>
<p><img src="_page_45_Picture_2.jpeg" alt=""></p>
<p>Introducing 3D assets in the background of a 2D game can add nice depth to a scene without compromising the gameplay. Top and middle images are from the upcoming <em>Metroidvania</em>-style game <em>Aeterna Noctis,</em> by Aeternum Game Studios S.L.. Bottom image is from <em>Last Night</em> by Odd Tales.</p>
<h2 id="camera-stacking">Camera Stacking</h2>
<p>Camera Stacking allows you to layer camera outputs and combine them in one final image. You can combine 2D, 3D, and UI objects with Camera Stacking.</p>
<p>At least two cameras are required in the scene for stacking. Choose which one will be the Base Camera for the image you want to be rendered first, and any additional cameras need to be set to Overlay.</p>
<table>
<thead>
<tr>
<th>▼ Camera</th>
<th></th>
<th>9 花</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Render Type</td>
<td>Base</td>
<td></td>
<td>D</td>
</tr>
<tr>
<td>▼ Projection</td>
<td>V<br>Base</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Projection</td>
<td>Overlay</td>
<td></td>
<td>▶</td>
</tr>
<tr>
<td>Size</td>
<td>5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Clipping Planes</td>
<td>Near 0.3</td>
<td></td>
</tr>
</tbody>
</table>
<p>Setting up Camera Stacking</p>
<p>The Base Camera needs to know which cameras overlay on top and in what order. To do that, go to the Stack option, and select a camera to overlay with the <strong>+</strong> button. Change the rendering order of Overlay Cameras as needed by dragging them up or down in the list.</p>
<table>
<thead>
<tr>
<th>Target Eye</th>
<th>Both</th>
<th></th>
<th>&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td>▼ Stack</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>= Camera 2</td>
<td>Overlay</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Camera 1</td>
<td>Overlay</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>+</td>
<td>-</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Selecting cameras to be rendered as overlays</p>
<p>Use layers to set which objects are rendered by each of the cameras. By default, cameras render every layer, but you can change that by selecting which layers are rendered by the camera in the Culling Mask option on a Camera component.</p>
<table>
<thead>
<tr>
<th>Culling Mask</th>
<th>Default</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Occlusion Culling</td>
<td></td>
<td>Nothing</td>
<td></td>
</tr>
<tr>
<td>Environment</td>
<td></td>
<td>Everything</td>
<td></td>
</tr>
<tr>
<td>Background Type</td>
<td>&gt;</td>
<td>Default</td>
<td></td>
</tr>
<tr>
<td>Volumes</td>
<td></td>
<td>TransparentFX</td>
<td></td>
</tr>
<tr>
<td>Mask</td>
<td></td>
<td>Ignore Raycast</td>
<td></td>
</tr>
<tr>
<td>Trigger</td>
<td></td>
<td>Water</td>
<td></td>
</tr>
<tr>
<td>Update Mode</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Choosing layers to render in the camera&#39;s Culling Mask option</p>
<p>Now, select the GameObjects you want the camera to render, and change their layer to match the one set earlier. That way, objects are categorized to be rendered by different cameras, such as a 3D background and 2D platform layers.</p>
<h2 id="cinemachine-for-2d">Cinemachine for 2D</h2>
<p>Once you&#39;ve selected the camera type, you&#39;ll need to set it up to follow the gameplay. Unity&#39;s <a href="https://docs.unity3d.com/Packages/com.unity.cinemachine@2.8/manual/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Cinemachine</a> system provides the functionality to do this and much more, such as confining the camera to level bounds, setting up camera transitions, noise, and so on. This section highlights some of the core Cinemachine functionality for 2D games.</p>
<p>To get started, install Cinemachine from the Package Manager. Choose version 2.7.1 or later.</p>
<p>Cinemachine doesn&#39;t create new Unity cameras in a scene. Instead, when a new Cinemachine Virtual Camera or vcam is added to a scene, the <a href="https://docs.unity3d.com/Packages/com.unity.cinemachine@2.8/manual/CinemachineBrainProperties.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">CinemachineBrain</a> component is added to the main camera, along with a new GameObject with the default name CM vcam.</p>
<p>The Cinemachine Brain monitors all active Virtual Cameras in the scene. Animate the vcams with keyframes, blend or smoothly transition between the cameras, or create a combination of the two to animate one camera while transitioning to another. All of the animation will be processed by the Cinemachine Brain and applied to the main camera – think of it as a powerful animation system that drives your main camera.</p>
<p>To create a 2D virtual camera, click on <strong>Cinemachine &gt; Create 2D Camera</strong>. This will create a Virtual Camera set up for a 2D environment. If it&#39;s your first Virtual Camera in the scene, it will also add a Cinemachine Brain Component to your main camera.</p>
<table>
<thead>
<tr>
<th>▼ + √ CinemachineVirtualCamera</th>
<th></th>
<th>(?)</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Status: Standby</td>
<td>Solo</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Game Window Guides</td>
<td>&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Save During Play</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Priority</td>
<td>10</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Follow</td>
<td>J. Unit_Wolfman_Oriz (Transform)</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td>Look At</td>
<td>None (Transform)</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td>Standby Update</td>
<td>Round Robin</td>
<td></td>
<td>D</td>
</tr>
<tr>
<td>v Lens</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Orthographic Size</td>
<td>5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Near Clip Plane</td>
<td>0.3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Far Clip Plane</td>
<td>1000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Dutch</td>
<td></td>
<td>- 0</td>
<td></td>
</tr>
<tr>
<td>Transitions</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Body<br>A</td>
<td>Framing Transposer</td>
<td></td>
<td>▶</td>
</tr>
<tr>
<td>Aim</td>
<td>Do nothing</td>
<td></td>
<td>D</td>
</tr>
<tr>
<td>Noise</td>
<td>none</td>
<td></td>
<td>D</td>
</tr>
<tr>
<td>Extensions</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Add Extension</td>
<td>(select)</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Add Component</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Creating a Cinemachine Virtual Camera</p>
<p>Cinemachine needs an object to follow, so assign a player character in the Follow field. To ensure that you are operating on a 2D plane and that the camera isn&#39;t panning or tilting, check that the Look At field is empty and Body is set to Framing Transposer. Finally, set the Lens properties for your projects. Keep in mind that some options will be inherited from the main camera&#39;s properties.</p>
<p>Expand the Body properties field to find useful options to modify how the Virtual Camera follows its target, such as Offset, Damping, Dead, and Soft Zones. Experiment with these options during Play Mode, and the changes will be saved if you check the Save During Play option.</p>
<p>There is also an extension for the Virtual Camera, the CinemachineConfiner2D, which, when activated, limits the camera from moving outside Level bounds, ensuring the player will see only the parts that you want them to see. It also ensures you don&#39;t need to design unnecessary parts of the level.</p>
<p>To add CinemachineConfiner2D, select CinemachineConfiner2D from the Add Extension dropdown menu.</p>
<p>Adding CinemachineConfiner2D extension</p>
<p>Cinemachine2DConfiner requires a Collider 2D (Composite or Polygon) as a Bounding Shape 2D. Create an empty GameObject, and add a Composite Collider 2D and Box Collider 2D. A RigidBody 2D will be added automatically; set its Body Type to Static. Also, check the Used by Composite option on the Box Collider 2D. Now, drag this GameObject into the Bounding Shape 2D field of the CinemachineConfiner2D script. Don&#39;t forget to edit the size of the Box Collider 2D so that it&#39;s larger than the size of the camera.</p>
<p>Now the camera&#39;s frustum won&#39;t go out the bounding box of the collider. For more details, check the Cinemachine Confiner 2D <a href="https://docs.unity3d.com/Packages/com.unity.cinemachine@2.8/manual/CinemachineConfiner2D.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">documentation.</a></p>
<h3 id="draw-order">Draw order</h3>
<p>In a 2D game, all sprites and objects have the same depth. How can you sort them so that some appear in front of others?</p>
<p>Unity sorts Renderers according to a priority order that depends on their types and usages. You can specify the render order of Renderers using their <a href="https://docs.unity3d.com/Manual/SL-SubShaderTags.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Render Queue.</a> In general, there are two main queues: the <a href="https://docs.unity3d.com/ScriptReference/Rendering.RenderQueue.Geometry.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Opaque queue</a> and the <a href="https://docs.unity3d.com/ScriptReference/Rendering.RenderQueue.Transparent.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Transparent queue.</a> 2D Renderers are mainly within the Transparent queue and include the <a href="https://docs.unity3d.com/Manual/class-SpriteRenderer.html">Sprite</a>  <a href="https://docs.unity3d.com/Manual/class-SpriteRenderer.html">Renderer,</a> <a href="https://docs.unity3d.com/Manual/class-TilemapRenderer.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Tilemap Renderer,</a> and <a href="https://docs.unity3d.com/ScriptReference/Experimental.U2D.SpriteShapeRenderer.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Sprite Shape Renderer</a> types.</p>
<p>2D Renderers within the Transparent Queue generally follow a priority order. When two or more objects occupy the same space, Unity goes through this list and checks which object should be drawn on top. When there&#39;s a tie, and both objects have the same value, the next criteria on the list is evaluated. The priority order is:</p>
<ul>
<li><ol>
<li>Sorting Layer and Order in Layer</li>
</ol>
</li>
<li><ol>
<li>Specify Render Queue</li>
</ol>
</li>
<li><ol>
<li>Distance to Camera</li>
</ol>
</li>
<li><ol>
<li>Sorting Group</li>
</ol>
</li>
<li><ol>
<li>Material/Shader</li>
</ol>
</li>
</ul>
<p>When all of the above values are the same for both objects and a tiebreaker is needed, this process must choose which one to render on top. It&#39;s not an ideal solution, so make sure to set a distinct sorting order using Sorting Layers and Sorting Groups.</p>
<h3 id="sorting-layers">Sorting Layers</h3>
<p>The most important sorting criteria are <a href="https://docs.unity3d.com/Manual/2DSorting.html">Sorting Layers</a>. All 2D Renderers have this option, and it&#39;s the first thing you need to set up. There is a default sorting layer which you can edit by opening Project Settings, then specifying Tags and Layers options.</p>
<table>
<thead>
<tr>
<th>Project Settings</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td></td>
</tr>
<tr>
<td>Adaptive Performance<br>Audio</td>
<td>Tags and Layers</td>
<td></td>
<td>2<br>2<br>8</td>
</tr>
<tr>
<td>Burst AOT Settings<br>Device Simulator<br>Editor</td>
<td>&gt; Tags<br>Sorting Layers<br>D</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Graphics</td>
<td>Layer</td>
<td></td>
<td>Background</td>
</tr>
<tr>
<td>Input Manager</td>
<td>Layer</td>
<td></td>
<td>Default</td>
</tr>
<tr>
<td>Package Manager</td>
<td>Layer</td>
<td></td>
<td>Main</td>
</tr>
<tr>
<td>Physics<br>Physics 2D</td>
<td>Layer</td>
<td></td>
<td>Characters</td>
</tr>
<tr>
<td>Player</td>
<td>Layer</td>
<td></td>
<td>Foreground</td>
</tr>
<tr>
<td>Preset Manager<br>Quality</td>
<td>Layer</td>
<td></td>
<td>UI - Number Display</td>
</tr>
<tr>
<td>Scene Template</td>
<td>Layer</td>
<td></td>
<td>UI - Unit Display</td>
</tr>
<tr>
<td>Script Execution Order<br>Services<br>Do<br>Tags and Layers<br>TextMesh Pro<br>Do<br>Time<br>Timeline<br>Version Control<br>XR Plugin Management</td>
<td>A<br>Layers</td>
<td></td>
<td>+</td>
</tr>
</tbody>
</table>
<p>Editing the Sorting Layer</p>
<p>Add, delete, or change the order by dragging the handle on the left of the Layers. Layers that are higher on the list are rendered first and will appear further away from the camera.</p>
<p>Plan the Sorting Layers structure, even when designing a mockup to organize your scene early on. Set a sprite&#39;s sorting group as soon as you place it in the scene. These practices will help you to avoid a situation later in your project development when you suddenly realize you have to change sorting settings on potentially thousands of sprites.</p>
<h4 id="-avoid-creating-too-many-sorting-layers-"><strong>Avoid creating too many Sorting Layers</strong></h4>
<p>2D Lights rely on Sorting Layers, so consider lighting when you set the Sorting Layers structure. Know beforehand how you want the lights to behave in your game and what groups will be affected by them.</p>
<p>For example, if you&#39;re making an isometric game and plan to have torches that use 2D Lights, will the torches affect their entire surroundings or only the walls? Will characters be affected, or will they be drawn in front of the light? Will you need a Sorting Layer just for the objects that will receive light? Keep these kinds of questions in mind when you&#39;re editing Sorting Layers, and learn more about planning lighting in the <a href="#page-71-0">2D Lights</a> section.</p>
<p>Be wary of using too many Sorting Layers, which can cause you to lose oversight of all the details. When you need to sort renderers further, use Order in Layer. This allows you to sort objects that are on the same layer easily.</p>
<h4 id="-transparency-sort-mode-"><strong>Transparency Sort Mode</strong></h4>
<p>You might want a fake 3D view in your game, such as an axonometric or oblique projection for an isometric, top-down game with a bit of an angle, or a cabinet projection in brawler games. If so, you&#39;ll need to custom sort the renderers by Distance to Camera (point 3 on the sorting priority list above).</p>
<p>Choose a custom axis to sort objects. In the case of a top-down game or brawler, sort objects on the Y axis, so higher characters will be rendered below other characters, giving the illusion that they are further away. To edit this option, find the 2D Renderer Asset created when setting up URP, and change its Transparency Sort Mode option to Custom Axis, then set its Transparency Sort Axis value to 0, 1, 0.</p>
<p><img src="_page_51_Picture_0.jpeg" alt=""></p>
<p>Sorting sprites on the Y axis, the value (X:0, Y:1) 1 tells Unity to follow a downward vector (as in <a href="https://docs.unity3d.com/ScriptReference/Vector2.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Vector2.</a> <a href="https://docs.unity3d.com/ScriptReference/Vector2.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">down</a>) for the sorting criteria. The sprites at the top will be drawn first, and the ones at the bottom later, making them visible at the front.</p>
<h2 id="sorting-group">Sorting Group</h2>
<p>Even if you follow the previous steps and sort on the Y axis, the appearance of your character&#39;s parts might still display incorrectly.</p>
<p><img src="_page_51_Picture_4.jpeg" alt=""></p>
<p>Parts of the characters that are on the same Sorting Layer are mixed between two characters.</p>
<p>It&#39;s not a bug. This is just how sorting works. Sorting doesn&#39;t know which parts belong to which character if they are on the same Sorting Layer. Fortunately, Sorting Group is the fourth criteria on the sorting priority list. Sorting Group is a component that groups Renderers that share a common root for sorting purposes. All Renderers within the same Sorting Group share the same Sorting Layer, Order in Layer, and Distance to Camera.</p>
<p>When using characters or other objects that consist of a couple of sprites, put this script on its Parent object (highest in the hierarchy), and set Sorting Layer and Order in Layer just like on any other 2D Renderer. You can see an example of this in this <a href="https://youtu.be/DCAH1rlwAr4?t=1073?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Unite Now technical session.</a></p>
<p><img src="_page_52_Figure_1.jpeg" alt=""></p>
<p>Creating a Sorting Group in the parent GameObject to ensure that this object and its child objects get sorted as a single element avoiding potential conflicts between its parts and other sprites in the game</p>
<p><img src="_page_52_Picture_3.jpeg" alt=""></p>
<p>The Sorting Group makes the characters appear as they should.</p>
<p>You can also nest Sorting Groups. If you have weapons consisting of multiple sprites that you want to be generated randomly, put them in Sorting Groups to make them display correctly in characters&#39; hands.</p>
<h4 id="optimization-tips">Optimization tips</h4>
<ul>
<li>Consider using Tilemaps when your scene consists of many sprites. This enables you to trade many Sprite Renderers (they have an overhead) for just one Tilemap Renderer.</li>
<li>Mark your level colliders as Static for batching.</li>
<li>Put sprites that will likely be together on the scene in a Sprite Atlas.</li>
<li>Simplify sprites&#39; meshes by using the Custom Outline option in the Sprite Editor.</li>
<li>Cache Sprite Shape geometry by enabling Cache Geometry option (it appears when the Edit Spline button is on).</li>
</ul>
<h2 id="-span-id-page-53-0-span-2d-animation-"><span id="page-53-0"></span><strong>2D Animation</strong></h2>
<p>2D animation can be the most time-consuming and challenging part of developing art for a game. Creating stunning animated characters requires considerable animation knowledge of timing, momentum, kinematics, and more. Polishing every frame can take a long time, and storing and displaying these frames requires a lot of memory. Changing the timing or any part of a character can require every frame to be redrawn.</p>
<p>Historically, 3D animation has been more straightforward than 2D. You make a 3D model, rig it by adding a skeleton, set up bone weights, and animate it by setting keyframes that the software interpolates between. You make adjustments by editing the keyframes.</p>
<p>Thankfully, Unity has developed a toolset that brings greater efficiency to <a href="https://docs.unity3d.com/Packages/com.unity.2d.animation@5.0/manual/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">2D</a>  <a href="https://docs.unity3d.com/Packages/com.unity.2d.animation@5.0/manual/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">animation</a>, in many ways by mimicking the straightforward ease of the 3D animation process. The 2D Animation package allows you to import your character artwork directly from Photoshop into Unity.</p>
<h2 id="design-import-and-rig">Design, import and rig</h2>
<p>The most vital element in a game is the player&#39;s character, so take enough time to think through the character&#39;s design. There are a few key aspects to consider while planning.</p>
<h4 id="-perspective-"><strong>Perspective</strong></h4>
<p>The perspective you choose will impact how the game characters look and are animated. In most game views, characters can be drawn in profile. A slight rotation into a ¾ view allows more facial features to be shown.</p>
<p>When using an isometric or ¾ top-down perspective, you can create a similar view, but with a camera tilted a bit from the top to show facial detail. In this perspective, the character will be drawn facing multiple directions. Depending on your desired outcome and budget, you can choose from one of three commonly-used options:</p>
<ul>
<li>4 directions</li>
<li>6 directions</li>
<li>8 directions</li>
</ul>
<p><img src="_page_53_Figure_12.jpeg" alt=""></p>
<p>Different ways to handle top-down character animations</p>
<p><span id="page-54-0"></span>No matter which you choose, you will have to decide whether right- or leftfacing animations will have to be flipped to face the opposite direction. In this case, you&#39;ll need to draw respectively:</p>
<ul>
<li>3 directions: right, up, down</li>
<li>3 directions: right, right-up, right-down</li>
<li>5 directions: right, right-up, up, right-down, down</li>
</ul>
<p>If the animations are flipped, the character&#39;s hands will flip to match. If the character faces right and holds a sword in their right hand and a shield in their left, when the character is flipped to be left-facing, both weapons will have switched hands. Decide whether to accept this trade-off or spend more time making all of the animations face in the right direction.</p>
<p>If you&#39;re designing a traditional side-scrolling beat-&#39;em-up game, you can simply use one facing direction. Characters moving up and down will look like they&#39;re sidestepping.</p>
<p>Ultimately, it&#39;s up to you whether or not your character looks good in the game&#39;s environment after testing. Your vision is more important than having a realistic view angle and perspective.</p>
<h4 id="-reskinning-characters-"><strong>Reskinning characters</strong></h4>
<p>Another benefit to the 2D Animation package is that multiple characters can share the same skeleton and animations. Once you have designed, rigged, and animated one base character, you can then simply swap its skin.</p>
<p>Save time by planning ahead. Draw concepts of all the characters that will share the same skeleton, then check whether the skeleton will fit all of them. Do this by drawing a skeleton on a separate layer and overlaying it onto every character. Bear in mind that the layer count must be the same for all characters.</p>
<p><strong>Note:</strong> In Unity 2021.1 and newer versions, a new feature called <a href="https://docs.unity3d.com/Packages/com.unity.2d.animation@6.0/manual/ex-skeleton-sharing.html">Skeleton sharing</a> streamlines this process.</p>
<p><img src="_page_54_Picture_11.jpeg" alt=""></p>
<p>Overlaying skeleton drawing in an image-editing application</p>
<h4 id="-span-id-page-55-0-span-performance-"><span id="page-55-0"></span><strong>Performance</strong></h4>
<p>Skeletal 2D animation requires more processing power than a frame-by-frame approach, which is essentially sprite swapping. A good performance tip is to install Unity&#39;s <a href="https://docs.unity3d.com/Packages/com.unity.2d.animation@5.0/manual/index.html#optional-performance-boost?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Burst and Collections</a> packages from the Package Manager. This will improve the runtime performance of the animated sprite&#39;s deformation.</p>
<p>Next, determine the resources you&#39;ll need for your target platforms and how many characters will be onscreen at once.</p>
<p>For example, with an adventure game where there will be two or three characters on the screen, you can be less conservative with the character detail. You&#39;ll have the luxury of making additional bones and layers, as well as advanced IK – moving eyes, fingers, and more.</p>
<p>However, a mobile RPG or shooter with big battles and more than 10 characters should have simpler rigs. It would be reasonable, for example, to have one bone per limb instead of two, or to have a whole face sprite swap instead of having moving eyes on a different layer.</p>
<p>When designing game art, take care to plan ahead how many layers you&#39;ll need and how characters will be animated because it&#39;s almost impossible to change these elements later in production.</p>
<h4 id="-general-2d-animation-rules-"><strong>General 2D animation rules</strong></h4>
<p>Here are some good rules to go by when designing a character that will be rigged and animated later.</p>
<p><img src="_page_55_Picture_8.jpeg" alt=""></p>
<p>An example of a neutral character pose: Legs and arms can be any position, but they should be unbent. Straining bent limbs will cause pixel stretching.</p>
<ul>
<li>Draw the character in a neutral position with arms and legs straight. If the parts of the body are drawn bent, it can cause issues when you&#39;re animating.</li>
<li>Make the resolution a little higher than your game&#39;s PPU suggests. While resolution can look good at rest, rotating and stretching images can cause pixelation.</li>
<li>If 2D Lighting will be used extensively in your game and you want to make the most of the normal maps, don&#39;t paint the light and shadow onto your sprite. Instead, paint some nondirectional shadows. This technique is called ambient occlusion. Your sprite will look better, but avoid using any directional light like sunlight.</li>
<li>Body part layers swapped using the Sprite Swap feature should be grouped accordingly. For example, all layers with mouth positions should be placed in a group called &quot;mouth&quot; in the image-editing app.</li>
</ul>
<p>Now that you know what to consider during designing, start up your graphic app of choice and start painting. Learn more about Sprite Swap by visiting the documentation page <a href="https://docs.unity3d.com/Packages/com.unity.2d.animation@5.0/manual/SpriteSwapIntro.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">here</a>.</p>
<h3 id="importing-a-character-into-unity">Importing a character into Unity</h3>
<p>Once completed, your character needs to be imported into Unity. The quickest way to import is through the 2D PSD Importer. This will import all of the character&#39;s layers as sprites and place them exactly as they were painted in the app.</p>
<p>If you&#39;re using the 2D project template in Unity, the importer should be already installed. If not, install it using Package Manager.</p>
<p>The exporting process simply requires files to be saved as PSB format. This is a format similar to Photoshop&#39;s PSD, but PSB allows for larger file sizes. If you&#39;re using Photoshop, select this format in the Save dialog box. If you&#39;re using another app, just export the project as a PSD file, and change the filename extension to PSB before importing into Unity.</p>
<p>Importing into Unity is the same as with other assets. Save the file to the Assets folder, or drag it into the Project window.</p>
<p>When an imported PSB file is selected, it will show options similar to the sprite import settings but with additional settings for 2D animation and rigging.</p>
<p><img src="_page_57_Picture_0.jpeg" alt=""></p>
<p>The Inspector for a character</p>
<p>The key options to set are:</p>
<ul>
<li>Import Hidden: This option imports all layers from a PSB file, including hidden layers.</li>
<li>Mosaic: This setting is only available if the Texture Type is set to Multiple. It makes sprites from imported layers and puts them onto a texture atlas. Leave this option enabled if you want to rig a character.</li>
<li>Character Rig: This option generates a character Prefab with the same layers hierarchy and position as in the PSB file. This must be on.</li>
<li>Use Layer Grouping: This adds layer grouping from the PSB file. Turn it on to group parts of a character, such as sprite swapped parts.</li>
</ul>
<p>After setting the options, click Apply. This finalizes the character Prefab, which can now be dragged into a Scene.</p>
<h2 id="building-a-character">Building a character</h2>
<p>To start rigging a character, click the Sprite Editor button in the Inspector to access the Sprite Import Settings.</p>
<p><img src="_page_58_Figure_2.jpeg" alt=""></p>
<p>How to choose tools in Sprite Editor&#39;s window</p>
<p>Select <a href="https://docs.unity3d.com/Packages/com.unity.2d.animation@5.0/manual/SkinningEditor.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Skinning Editor</a> from the drop-down menu in the top-left corner of the Sprite Editor window.</p>
<p><img src="_page_58_Figure_5.jpeg" alt=""></p>
<p>The Skinning Editor with options for animating a character</p>
<p><span id="page-59-0"></span>In this window, you can:</p>
<ul>
<li>Create and edit bones</li>
<li>Create and edit Sprite Geometry</li>
<li>Edit Bone Influence on sprites</li>
<li>Create Categories and Labels for use in Skins and Sprite Swap</li>
</ul>
<h4 id="-creating-the-skeleton-"><strong>Creating the skeleton</strong></h4>
<p>Start by making the character&#39;s skeleton. Choose the Create Bone button and left-click on the main window area. The first click will create a bone center, and the second will mark the bone tip location. This tool chains and nests bones inside one another.</p>
<p>If you want to change the bone placement, press the right mouse button and leftclick where you want the new bone to be located. To control which existing bone will be the parent of the bones to be created, select the existing bone with the left mouse button, then create the new bone.</p>
<p>Use the Edit Bone button to refine bones. The Split Bone button allows you to split bones in two. This is a good option for making limbs. If you make one leg bone and click where the knee should be, the bone will then split into thigh and calf.</p>
<p><img src="_page_59_Figure_9.jpeg" alt=""></p>
<p>The Bone tab opened to organize parent and children bones</p>
<p><span id="page-60-0"></span>You can also reparent and rename bones in the bone list view. To open this view, click the Visibility button on the right of the top bar, then select the Bone tab. To change the bone&#39;s parent, simply drag it in the list view. You can rename bones by clicking on the active bone&#39;s name. Giving bones a name will help you find them later. To verify that the hierarchy is correct, select the Preview Pose button and test some poses. To reset bones positions, press the Reset Pose button on the toolbar.</p>
<h4 id="-sprite-geometry-"><strong>Sprite Geometry</strong></h4>
<p>In order to assign sprites to bones, they&#39;ll need to have geometry created. Start by pressing the Auto Geometry button. A small pop-up window will open, allowing you to define how the geometry will be created.</p>
<p>It&#39;s a good idea to set all sliders to 0 to keep the geometry as simple as possible. Enable the Weights option to bind bones to the sprites automatically. Clicking the Generate For All Visible button will create and set bone weights for all sprites. To do this for an individual sprite, simply double-click on the sprite. This is useful for tweaking the geometry of certain sprites.</p>
<p><img src="_page_60_Figure_4.jpeg" alt=""></p>
<p>Autogenerating sprites&#39; geometry</p>
<p><span id="page-61-0"></span>To go beyond this generated geometry and have full control on a number of vertices and how the geometry bends, the mesh will need to be edited manually. Use the following <a href="https://docs.unity3d.com/Packages/com.unity.2d.animation@5.0/manual/SkinEdToolsShortcuts.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">tools</a>:</p>
<ul>
<li>Create Vertex: Create new vertices (or points), or move or delete those points</li>
<li>Create Edge: Creates edges, either between two existing points or by creating a new point using the left mouse button; the right mouse button deselects the currently selected point and lets you make an edge between other vertices</li>
<li>Edit Geometry: Move vertices</li>
<li>Split Edge: Splits an edge by creating a vertex in the middle</li>
</ul>
<p>Use as few vertices as possible. Fewer vertices will help you save on performance, since each vertex position needs to be calculated based on the bones&#39; rotation. Fewer vertices also make for better-looking mesh bending since it&#39;s easier to set weights for fewer points. Additionally, each target platform will have an ideal game vertex count, so it&#39;s always a good idea to optimize geometry.</p>
<h4 id="-weights-"><strong>Weights</strong></h4>
<p>Once the geometry is nice and clean for all of your sprites, it&#39;s time to <a href="https://docs.unity3d.com/Packages/com.unity.2d.animation@5.0/manual/CharacterRig.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">set up</a>  <a href="https://docs.unity3d.com/Packages/com.unity.2d.animation@5.0/manual/CharacterRig.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">weights.</a> Weights define bone influence on each vertex from 0 to 1, where 0 means that a bone has no influence over the vertex, and 1 means that the vertex will move like it&#39;s glued to the bone. Good weights on the mesh can allow for great-looking bending. Setting weights incorrectly can break the game&#39;s illusion and distort your sprites.</p>
<p>To start setting up weights, you need to define which bones will affect a certain sprite. Click the Bone Influence button, and select a sprite.</p>
<p><img src="_page_61_Figure_9.jpeg" alt=""></p>
<p>Setting bone influence on a sprite</p>
<p>In the small pop-up window, you can set which bones influence the selected sprite. Set only the relevant bones that need to affect the sprite, and remove the rest.</p>
<p>From here, set up weight by using the Weight Brush and Weight Slider. The Weight Brush quickly adds the influence of the selected bone to the vertices by painting on them with the mouse. The Weight Slider is more precise, allowing you to select one or more points, then determine the exact influence of each bone with a slider. The brush is useful for quick weight setting, and the slider is useful for fine-tuning the areas where bones bend, like elbows and knees.</p>
<p><img src="_page_62_Picture_2.jpeg" alt=""></p>
<p>How to place vertices for the best looking limb bending</p>
<p><strong>Tip:</strong> When you&#39;re working with elbows and knees, get the best-looking results by aligning the inner and outer vertices to a line which runs through the middle of the bending point where the two bones meet. This line should cross the bones at a 45-degree angle. These vertices should be influenced only by the upper bone. However, every character will be different, so feel free to fiddle with the weights and customize for the best results.</p>
<p>To speed things along, open the <em><a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Dragon Crashers</a></em> project, and find the following character Prefabs in the section for Prefabs and Prefab Variants:</p>
<ul>
<li>Prefab_Character_Base<ul>
<li><em>PV_Character_Witch</em> (uses a different Sprite Library for auto rebinding)</li>
<li><em>PV_Character_Knight</em></li>
<li><em>PV_Character_Wolfman</em></li>
<li><em>PV_Character_Skeleton</em></li>
</ul>
</li>
</ul>
<p>These Prefabs are great examples of shareable animations between characters of the same structure.</p>
<h2 id="2d-inverse-kinematics">2D Inverse Kinematics</h2>
<p>You probably don&#39;t think about it every day, but the human body&#39;s movement is very complex. If you want to grab a glass of water off of a table, your hand must move to the point in space that the glass occupies. You do all this without even thinking about rotating your arm and forearm, as your brain processes these calculations in the background.</p>
<p>To animate the same movement in a game, the rotation of both arm and forearm need to be animated at the same time. It&#39;s a challenging task to match both rotations while making a believable hand movement. The 2D Inverse Kinematics <a href="https://docs.unity3d.com/Packages/com.unity.2d.ik@3.0/manual/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">(2D IK)</a> tool, which is a part of the 2D Animation package, calculates the rotations and allows a chain of bones to move them to target positions.</p>
<p>To begin, you&#39;ll first need to add an IK Manager 2D on the object at the top of the hierarchy. This component will be responsible for managing all the <a href="https://docs.unity3d.com/Packages/com.unity.2d.ik@3.0/manual/index.html#ik-solversa-idiksolversa?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">IK Solvers</a> on the character.</p>
<table>
<thead>
<tr>
<th>▼ B √ IK Manager 2D (Script)</th>
<th></th>
<th>8 花</th>
</tr>
</thead>
<tbody>
<tr>
<td>IK Solvers</td>
<td></td>
<td></td>
</tr>
<tr>
<td>J None (Solver 2D)</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td></td>
<td></td>
<td>+</td>
</tr>
<tr>
<td>Weight</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>Restore Default Pose</td>
</tr>
</tbody>
</table>
<p>IK Manager 2D component</p>
<p>Clicking the <strong>+</strong> button will add a new solver. The solver will calculate bones&#39; rotation to match the target transform. There are three solvers available:</p>
<ul>
<li>Limb: This is the standard solver used for legs and arms, which can solve up to two bones and the Effector.</li>
<li>Chain (CCD) Cyclic Coordinate Descent: This solver gradually becomes more accurate the more times the algorithm is run and is suitable for a longer chain of bones.</li>
<li>Chain (FABRIK) Forward And Backward Reaching Inverse Kinematics: Like Chain (CCD), this solution becomes more accurate the more times its algorithm is run. It adapts quickly if the bones are manipulated in real-time to different positions.</li>
</ul>
<p>In humanoid characters, the Limb Solver is the best choice because it is fastest and optimized for two-bone limbs. Start by adding Limb Solver to IK Manager 2D&#39;s list, which will create a new GameObject that will include the Limb Solver 2D component. Rename this GameObject to something descriptive like &quot;Leg R LimbSolver2D&quot; or &quot;Arm L LimbSolver2D.&quot;</p>
<table>
<thead>
<tr>
<th># √ Limb Solver 2D (Script)<br>2</th>
<th></th>
<th></th>
<th>8<br>14</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Effector</td>
<td></td>
<td>None (Transform)</td>
<td></td>
<td>O</td>
</tr>
<tr>
<td>Target</td>
<td></td>
<td>None (Transform)</td>
<td></td>
<td>O</td>
</tr>
<tr>
<td>Flip</td>
<td></td>
<td>.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Constrain Rotation</td>
<td></td>
<td>&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Solve from Default Pose</td>
<td></td>
<td>&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Weight</td>
<td></td>
<td>200</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Create Target</td>
<td>Restore Default Pose</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Limb Solver 2D component</p>
<p>In order to work, the solver needs two GameObject Transforms: <a href="https://docs.unity3d.com/Packages/com.unity.2d.ik@3.0/manual/index.html#creating-an-effector-and-its-targeta-idtargeta?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">the Effector and</a>  <a href="https://docs.unity3d.com/Packages/com.unity.2d.ik@3.0/manual/index.html#creating-an-effector-and-its-targeta-idtargeta?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Target</a>. The Effector is placed inside the last bone in a chain, for example, the tip bone of a finger, and from there, it will try to reach the Target&#39;s position.</p>
<p>First, create the Effector. When creating an IK for a leg, there are two bones: the thigh and calf (or shin). Place the Effector as a child of the calf bone by selecting it and creating a new Empty GameObject. Rename the GameObject as Leg Effector, and move the Effector to the tip of the bone.</p>
<p>Add the newly created Effector to the Effector field on the Limb Solver 2D, and press the Create Target button. A target GameObject will be created inside of the Limb Solver object.</p>
<p><img src="_page_64_Picture_5.jpeg" alt=""></p>
<p>Now, when the Target object moves the leg will follow.</p>
<p>2D IK in action: When you move the Target GameObject, thigh and calf rotations will be calculated automatically to match the Target&#39;s position.</p>
<p>Repeat the whole process of adding IKs with the other limbs. IKs can also be added on non-limb bones, for example, on the head and neck, which allows the character to look around at things.</p>
<p>Once you&#39;ve mastered this, there are more advanced use cases. For example, you can set up IKs to make your character aim a gun or to create a procedural walking animation.</p>
<h2 id="sprite-swap-and-skins">Sprite Swap and Skins</h2>
<p>Not everything can be animated by rotating a bone. Sometimes you need another facial expression or hand pose. In this case, you can exchange one sprite with another by using Sprite Swap.</p>
<p>Start using Sprite Swap by assigning a category and label to each of the character&#39;s sprites. The fastest way to assign to sprites is from the Skinning Editor. Press the Visibility button, then go to the Sprite tab, where you will find a list of all sprites. If you&#39;ve put the layers for swap into separate groups before exporting to PSB, they should be grouped now. This is important because grouped sprites will be added to the Sprite Resolver to allow Sprite Swapping.</p>
<p><img src="_page_65_Figure_3.jpeg" alt=""></p>
<p>Assigning Category and Label to each sprite in Skinning Editor (sprites with the same category can be used and swapped in Sprite Resolver)</p>
<p>Select all the sprites and groups in the list, and right-click on them. Next, select the following two options in order: Convert Layer to Category and Convert Group to Category. These options will assign an appropriate Category and Label to each sprite automatically.</p>
<p>Sprites that are meant to be swapped will be in one category based on group name. Click the Apply button on top. A Sprite Library asset will be created inside the character Prefab, containing all the categories and labels created so far. Remember this asset, as it will be needed later.</p>
<p>If you take a look at the sprites which were in the groups, you&#39;ll see there&#39;s now one sprite per category, with the Sprite Resolver component added.</p>
<p><span id="page-66-0"></span></p>
<table>
<thead>
<tr>
<th>▼ Sprite Resolver (Experimental)</th>
<th></th>
<th>8 花</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Category</td>
<td>mouth</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Label</td>
<td>mouth normal</td>
<td></td>
<td>&gt;</td>
</tr>
<tr>
<td>F</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Sprite Resolver component</p>
<p>Sprites that were meant to be swapped have been added to the Sprite Resolver, and you can now implement sprite swap by clicking on them.</p>
<p>Use Sprite Swap to animate facial expressions, eyes and mouths, make lipsynced animations, change hand gestures, and more. Sprite Swap also allows character equipment like hats and armor to be swapped.</p>
<h4 id="-skins-"><strong>Skins</strong></h4>
<p>Sprite Library assets let you create skins for your character. A skin changes the look of the character while retaining its animations, which is a great timesaver, indeed. One base character can have all the scripts, and any change will be also applied to other characters.</p>
<p>Here is the workflow for setting up skin support on characters:</p>
<ul>
<li><ol>
<li>Finish a base character: Rig it, set up IKs and Sprite Library. Make a Prefab from the character. You can animate the character at any point.</li>
</ol>
</li>
<li><ol>
<li>Go to the Skinning Editor of the base character, and click the Copy button on the toolbar. This will copy bones and meshes with weights.</li>
</ol>
</li>
<li><ol>
<li>Create a Prefab Variant of this character this will be the new character with a new look.</li>
</ol>
</li>
<li><ol>
<li>Import the PSB of the new character, and open its Skinning Editor.</li>
</ol>
</li>
<li><ol>
<li>Paste in the skeleton copied from step 2 by clicking the Paste button on the toolbar. Make sure Bones and Mesh options are selected in the pop-up window, and click the Paste button to confirm.</li>
</ol>
</li>
<li><ol>
<li>Fix the geometry so it fits the new sprites. Double check the weights.</li>
</ol>
</li>
<li><ol>
<li>Press the Visibility button, and go to the Sprite tab. Select all the sprites and groups in the list, right click on them and select two options: Convert Layer to Category and Convert Group to Category. Hit the Apply button on top.</li>
</ol>
</li>
<li><ol>
<li>Go to the Prefab variant created in step 3. Go to the Sprite Library component and swap the Sprite Library asset for a new character.</li>
</ol>
</li>
<li><ol>
<li>To create new characters, follow steps 2 through 8.</li>
</ol>
</li>
</ul>
<p><img src="_page_67_Picture_0.jpeg" alt=""></p>
<p>Choosing Sprite Library Asset in Sprite Library component</p>
<p>By following this workflow, you&#39;ll have one base character Prefab. Other characters will be Variants of this Prefab, so they will have the same components as the base Prefab. If changes are made to the base character, for example, adding or changing IKs or Sorting Groups, other characters will inherit those changes.</p>
<h4 id="animation-basics">Animation basics</h4>
<p>Animations are very important if you want to create convincing characters.</p>
<p>Creating great animation requires you to learn animation principles and the tools to apply them. Learning basic animation principles is often neglected, but your game will benefit greatly if you spend a little time polishing your character movement.</p>
<p>To create your first animation, open an Animation window by going to <strong>Window &gt; Animation &gt; Animation.</strong></p>
<p><img src="_page_67_Picture_7.jpeg" alt=""></p>
<p><img src="_page_67_Figure_8.jpeg" alt=""></p>
<p>Select your character. Clicking the Create button will create the first Animation Clip, and you can start by giving the clip a name. An Animation Clip is like a linear recording of how an object&#39;s position, rotation, scale, and other properties change over time. It also creates an Animator Controller, which takes charge of all animation clips and keeps track of which clip should be playing and when the animations should change or blend together.</p>
<p>Start animating by clicking the red Record button. Now, all the changes made to the character will be recorded to an animation clip.</p>
<p><img src="_page_68_Picture_2.jpeg" alt=""></p>
<p>When the Record button is pressed, every change will create a keyframe on the Animation Timeline.</p>
<p>On the right side of the Animation View is the timeline for the current clip. The keyframes for each animated property appear in this timeline. The white vertical head line shows the current frame – be sure it&#39;s on the frame 0. Pose your character however you like. One or more keyframes will be created on the timeline, and on the left the names of current animated properties will show.</p>
<p><img src="_page_68_Picture_5.jpeg" alt=""></p>
<p>Now, move the head line a few frames forward and change the character pose. A new keyframe (or keyframes) will pop up.</p>
<p>Adding another keyframe along the Timeline creates an animation that will interpolate the keyframes.</p>
<p>When you press the Play button, you&#39;ll see your character moving. You&#39;ve now created your first animation.</p>
<h4 id="-animating-sprite-swap-facial-expressions-"><strong>Animating Sprite Swap – facial expressions</strong></h4>
<p>Animating Sprite Swap works similarly, but it requires one additional step when setting keyframes.</p>
<p><img src="_page_69_Picture_2.jpeg" alt=""></p>
<p>How to animate Sprite Resolver by disabling keyframe interpolation</p>
<p>Set the new keyframes by choosing a sprite in the Sprite Resolver component. By default, the values between keyframes are interpolated, meaning that if you want to change from the first sprite in the list to the last one in a later frame, all the sprites in between would be shown. Sprite Resolver uses integer numbers to define the index of each sprite, so the interpolation in this case is not desired. To avoid that, select all the keyframes containing Sprite Resolver values, right click and select Both Tangents – Constant. Now the animation timeline will &quot;hold&quot; the values after keyframes, instead of interpolating them, and the Sprite Swap animation should play correctly.</p>
<p><img src="_page_69_Figure_5.jpeg" alt=""></p>
<p>Setting Constant Tangents on Sprite Resolver keyframes so the values are not interpolated</p>
<h2 id="optimization-tips">Optimization tips</h2>
<ul>
<li>Install Burst Package to improve 2D Animation performance.</li>
<li>When making a skeleton, avoid using more bones and sprites than you need.</li>
<li>Simplify skeleton meshes by using as few vertices as possible.</li>
<li>Turn on Culling in the animators. This option will be turned off when the animated character is offscreen to save performance.</li>
<li>Avoid using skeletal animations for objects or characters that are small or come in large numbers, such as background birds, flies, or small animals. Instead, use different techniques like frame-by-frame animation or shaders.</li>
</ul>
<h2 id="-span-id-page-71-0-span-2d-lights-"><span id="page-71-0"></span><strong>2D Lights</strong></h2>
<p>Unity&#39;s advanced <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@13.1/manual/Lights-2D-intro.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">2D dynamic lighting system</a>, in conjunction with normal maps and mask maps, makes your characters pop with gorgeous silhouette lightning and clearly shaded details.</p>
<p>Lit environments are more immersive and believable because of the subtle interactions between characters, objects, and the lighting system.</p>
<p>2D Lights can be an integral part of the gameplay. For example, you can use them to create a player&#39;s flashlight as it illuminates just part of a pitch-black corridor, or to show a surveillance camera&#39;s cone of vision that the player needs to avoid.</p>
<p>Dynamic lighting can dramatically change a level&#39;s mood, bring out the details of a cave&#39;s torchlit wall, act as light beams coming through a window to illuminate sparkling dust motes, or simply be animated to simulate the day and night cycle.</p>
<p><img src="_page_71_Picture_5.jpeg" alt=""></p>
<p>Let&#39;s look at the variety of 2D Lights you can create and how to customize them.</p>
<p>Image from <em><a href="https://store.steampowered.com/app/1283410/Tails_of_Iron/">Tails of Iron</a></em> by Oddbug Studio</p>
<p><img src="_page_71_Picture_8.jpeg" alt=""></p>
<p>An image from <em>Ultimate Action Hero</em>, a game in development by Jarek Majewski.</p>
<h2 id="-span-id-page-72-0-span-types-and-use-cases"><span id="page-72-0"></span>Types and use cases</h2>
<p>To add a new 2D Light, go to <strong>GameObject &gt; Light &gt; 2D</strong>, and select a light type.</p>
<p><img src="_page_72_Picture_2.jpeg" alt=""></p>
<p>Adding a 2D Light to the scene</p>
<p>There are <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@13.1/manual/LightTypes.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">five types</a> of 2D Lights shapes.</p>
<h4 id="-freeform-"><strong>Freeform</strong></h4>
<p>This kind of light has a polygonal shape that can be edited in a similar way to Sprite Shape. This is a good tool for efficiently lighting a large part of the environment (such as a lava pool), simulating light shapes (such as god rays coming through a ceiling hole), or conforming to the shape of a window where the light is projected.</p>
<p><img src="_page_72_Picture_7.jpeg" alt=""></p>
<p>Editing the Freeform 2D Light</p>
<h4 id="-span-id-page-73-0-span-sprite-"><span id="page-73-0"></span><strong>Sprite</strong></h4>
<p>This shape allows the use of any sprite as a light&#39;s texture. This comes in handy if you want a particular shape that is impossible to achieve with other light types. Some good examples of possible textures are lens flares, glares, light cookies, light shape projections like disco ball lights, or baby lamps projecting stars against the wall.</p>
<p><img src="_page_73_Picture_2.jpeg" alt=""></p>
<p>Sprite Light in action</p>
<h4 id="-parametric-"><strong>Parametric</strong></h4>
<p>These lights can be shaped like an n-sided polygon. This is a specific type of light that can be used in inorganic or stylized environments. In future Unity versions, these light types will be default shapes inside the Freeform light options.</p>
<p><img src="_page_73_Picture_6.jpeg" alt=""></p>
<p>Parametric Lights with 3, 5, and 8 sides</p>
<h4 id="-span-id-page-74-0-span-point-spot-"><span id="page-74-0"></span><strong>Point/Spot</strong></h4>
<p>The shape of this light can be a circle or a circle sector. This option is good for spotlights or to light a specific point with torch fires, candles, car lights, flashlights, volumetric light, and so on.</p>
<p><img src="_page_74_Picture_2.jpeg" alt=""></p>
<p>Point light with full and partial arcs</p>
<h4 id="-global-"><strong>Global</strong></h4>
<p>A Global Light doesn&#39;t have a shape and instead lights all objects on the targeted sorting layers. Only one Global Light can be used per Blend Style (the method of interaction between light and the sprites), and per sorting layer. Use it first to add a base environment light.</p>
<table>
<thead>
<tr>
<th>O Inspector<br>Project Settings</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>a :</th>
</tr>
</thead>
<tbody>
<tr>
<td>✔ Light_Global_Main<br>8</td>
<td></td>
<td></td>
<td></td>
<td>Static</td>
<td></td>
</tr>
<tr>
<td>Tag Untagged</td>
<td>&gt;</td>
<td>Layer Default</td>
<td></td>
<td></td>
<td>œ</td>
</tr>
<tr>
<td>1<br>Transform<br>&gt;</td>
<td></td>
<td></td>
<td></td>
<td>3<br>2</td>
<td></td>
</tr>
<tr>
<td>Position</td>
<td>X 0.011</td>
<td>Y 2.043</td>
<td>Z O</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Rotation</td>
<td>×<br>O</td>
<td>Y O</td>
<td>Z<br>O</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Scale</td>
<td>×<br>1</td>
<td>Y 1</td>
<td>Z<br>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>▼ ■ ▼ Light 2D (Experimental)</td>
<td></td>
<td></td>
<td></td>
<td>8 花</td>
<td></td>
</tr>
<tr>
<td>Light Type</td>
<td>Global</td>
<td></td>
<td></td>
<td></td>
<td>œ</td>
</tr>
<tr>
<td>Light Order</td>
<td>O</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Blend Style</td>
<td>Default</td>
<td></td>
<td></td>
<td></td>
<td>V</td>
</tr>
<tr>
<td>Color</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>P</td>
</tr>
<tr>
<td>Intensity</td>
<td>0.32</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Target Sorting Layers</td>
<td>Mixed</td>
<td></td>
<td></td>
<td></td>
<td>▶</td>
</tr>
<tr>
<td></td>
<td>Add Component</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Option for Global Light</p>
<h2 id="how-to-use-2d-lights">How to use 2D Lights</h2>
<p>2D Lights work with the Sprite Renderer, the Sprite Shape Renderer, and the Tilemap Renderer. To fit the workflow, they use Sorting Layers. Each light can affect one or more sorting layers. Select which layers will be affected in the Target Sorting Layers dropdown list.</p>
<p><img src="_page_75_Figure_2.jpeg" alt=""></p>
<p>Selecting which Sorting Layers should be affected by 2D Light</p>
<p><img src="_page_75_Figure_4.jpeg" alt=""></p>
<p>Setting up 2D Lights in <em><a href="https://store.steampowered.com/app/1283410/Tails_of_Iron/">Tails of Iron</a></em> by Oddbug Studio</p>
<p>To control the rendering order of lights that are on the same Sorting Layer, use the Light Order option.</p>
<p>The <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@13.1/manual/LightBlendStyles.html">Blend Style</a> option allows you to select the blend style used by this Light. Different blend styles can be customized in the 2D Renderer Asset. Read more about common properties used by the different Light types <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@13.1/manual/2DLightProperties.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">here</a>.</p>
<p>The Alpha Blend on Overlap option blends overlapping lights instead of multiplying their intensity. This option can change 2D light into shadows. Simply set the light&#39;s intensity below 1, and choose a light blue color. You can also attach it to a character to cast a subtle shadow.</p>
<p><img src="_page_76_Picture_0.jpeg" alt=""></p>
<p>2D Lights overlap modes</p>
<p><img src="_page_76_Picture_2.jpeg" alt=""></p>
<p>Using Alpha Blend on Overlap to change 2D light into shadow</p>
<p><img src="_page_76_Picture_4.jpeg" alt=""></p>
<h4 id="secondary-texture-sprite-maps-">Secondary Texture (sprite maps)</h4>
<p>Adding Secondary Textures to sprites</p>
<p><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@13.1/manual/SecondaryTextures.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Normal maps and mask maps</a> are optional when using 2D Lights, but they can take your game&#39;s visuals to a whole new level if you have the budget, time, and art resources for it. Characters and the environment will have even more details that react to light, making their shapes look more defined and threedimensional.</p>
<p>Every sprite asset can have optional Secondary Textures assigned. These textures can be used by Materials. Change the Secondary Textures by going into <strong>Sprite Editor &gt; Secondary Textures</strong>. By default, you can assign two types of textures: normal map and mask map. Normal map contains the angle of every pixel on the object, and mask map can be used for rim lighting and more. You can add your own textures and reference them by name in <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@13.1/manual/ShaderGraph.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Shader Graph</a> shaders.</p>
<p><img src="_page_77_Picture_1.jpeg" alt=""></p>
<p>Adding Secondary Textures to sprites</p>
<p>There are some good reasons to assign textures on an asset level instead of in the material.</p>
<p>One benefit is that Sprite Renderers and other renderers that use sprites can share a material, even when the sprites and secondary textures are different. This means they can be batched to render more efficiently.</p>
<p>You&#39;ll need to add normal maps and mask maps to a material when you have a sprite shader. Every sprite would need its own material with a sprite, normal map, and mask map. That would quickly escalate to hundreds of materials in the project. However, when setting the additional textures for every sprite, you can use just one Sprite Material. One material also means one draw call instead of hundreds.</p>
<table>
<thead>
<tr>
<th>Frame Debug</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>: 0 ×</th>
</tr>
</thead>
<tbody>
<tr>
<td>Disable<br>Editor</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>22</td>
<td></td>
<td>of 207</td>
<td></td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>UniversalRenderPipeline.RenderSingleCam 207 A</td>
<td>RenderTarget</td>
<td></td>
<td>CameraColorTexture</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ScriptableRenderer.Execute: New 2D Rei 207</td>
<td>- Channels All R<br>RT 0</td>
<td>G</td>
<td>B</td>
<td>A</td>
<td>Levels C</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ColorGradingLUT</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&gt; ScriptableRenderPass.Configure<br>1</td>
<td>3840x2160 B10G11R11_UFloatPack32</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>201<br>T Render 2D Lighting</td>
<td>Event #22: Draw Dynamic</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2<br>Default</td>
<td>Shader</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Universal Render Pipeline/2D/Sprite-Lit-Default, SubShader #0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>T RenderLoop.Draw<br>199</td>
<td>Pass</td>
<td></td>
<td>#0 (Universal2D)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>Keywords</td>
<td></td>
<td></td>
<td></td>
<td>USE SHAPE LIGHT TYPE O</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>Blend</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>SrcAlpha OneMinusSrcAlpha</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic<br>Draw Dynamic</td>
<td>ZClip</td>
<td>True</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>ZTest</td>
<td>LessEqual</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>ZWrite</td>
<td>Off</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>Cull</td>
<td>Off</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>Conservative</td>
<td>False</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>Preview ShaderProperties</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>Textures</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>MainTex</td>
<td></td>
<td></td>
<td></td>
<td>f</td>
<td>34</td>
<td>albedo</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>_MaskTex</td>
<td></td>
<td></td>
<td></td>
<td>f</td>
<td></td>
<td>Unity White</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>_ShapeLight Texture0</td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td>_ShapeLightTexture0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>Floats</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>_HDREmulation Scale</td>
<td></td>
<td></td>
<td></td>
<td>f</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic<br>Draw Dynamic</td>
<td>UseSceneLighting</td>
<td></td>
<td></td>
<td></td>
<td>f</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>Vectors</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>_ProjectionParams<br>_MainTex_ST</td>
<td></td>
<td></td>
<td></td>
<td>V<br>V</td>
<td>(1, 1, 0, 0)</td>
<td>(-1, 0.3, 1000, 0.001)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>_ShapeLightBlendFactors0</td>
<td></td>
<td></td>
<td></td>
<td>f</td>
<td>(1, 0, 0, 0)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>_ShapeLightMaskFilter0</td>
<td></td>
<td></td>
<td></td>
<td>f</td>
<td>(0, 0, 0, 0)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>_ShapeLightInvertedFilter0</td>
<td></td>
<td></td>
<td></td>
<td>f</td>
<td>(0, 0, 0, 0)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>_RendererColor</td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td>(1, 1, 1)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>Matrices</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td>unity_MatrixVP</td>
<td></td>
<td></td>
<td></td>
<td>V</td>
<td>0.11<br>0</td>
<td>0<br>O<br>-0.2</td>
<td></td>
<td>2.1<br>-0.082</td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>0</td>
<td>-0.001</td>
<td>0.96</td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>O<br>O</td>
<td></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>Draw Dynamic</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Using the Frame Debugger allows you to observe every step taken to render a frame. Having many Materials that can&#39;t be batched takes a toll on performance.</p>
<h2 id="normal-maps">Normal maps</h2>
<p>A normal map done well can make or break the illusion of a sprite being 3D. Every pixel in a normal map stores data about the angles of the main texture. The red, green, and blue (RGB) channels store angle data for the X, Y, and Z coordinates. Every light that uses a normal map has a direction, and pixels on a texture with a normal map are shaded based on this direction and the direction of the pixel. This works the way it does in real life – if a pixel is facing the light&#39;s direction then it will be lit, and if it&#39;s facing away it receives no light.</p>
<p>Now, take a look at how RGB values affect the angles of a normal map.</p>
<p><img src="_page_78_Picture_5.jpeg" alt=""></p>
<p>A normal map</p>
<p><span id="page-79-0"></span>The above image is a normal map in which the pixels are facing the camera. Its RGB values are 127, 127, and 255, respectively. Each color channel can have a value from 0 to 255, so 127 is near the middle. To face the surface left (-90 degrees), the R color value needs to be set to 0. To face the surface right, set R to 255. To face straight down or up, set the G channel to 0 or 255, respectively.</p>
<h4 id="-preparing-sprites-for-2d-lighting-"><strong>Preparing sprites for 2D lighting</strong></h4>
<p>Take note of the base-color sprite. If you plan to use 2D lighting extensively in your game and want to make the most of the normal maps, don&#39;t paint the light and shadow onto the sprite.</p>
<p>2D lighting doesn&#39;t look good on a sprite that already has shadows painted on. You will also end up doing double the amount of work because you&#39;ll be painting the lighting in the normal maps. Instead, paint some non-directional shadows, and your sprite will look better as long as you avoid any directional light, such as from the sun.</p>
<p><img src="_page_79_Picture_4.jpeg" alt=""></p>
<p>With 2D Lights turned off, the sprite has the color information (albedo) but looks flat because it doesn&#39;t contain light or shadow information.</p>
<h4 id="-normal-map-painting-techniques-"><strong>Normal map painting techniques</strong></h4>
<p>One way to paint a normal map is to make drawings of your sprite that are lit from different angles, then combine them into one texture. The sprite will be lit with one light from the right in the R channel and one light from the top in the G channel. In the B channel, the sprite is lit from the front, but for the sake of simplicity, you can omit this channel when using a normal map with 2D sprites. This is because front lighting in 2D won&#39;t add that much to the overall shading.</p>
<p>However, this approach can be time-consuming, as you will need to paint your shading at least twice for the X and Y axis.</p>
<p><img src="_page_80_Figure_0.jpeg" alt=""></p>
<p>How to combine two shaded grayscale (lit from top and from right ) images into a normal map</p>
<p>Another painting approach is to use a normal map-generator app. Open a sprite in a generator app, and you can generate a normal map with just a couple of clicks. Generator apps do not take into account the angles of your sprite, so avoid using them on the entire sprite. They also don&#39;t recognize the objects. They instead estimate shapes from the sprite colors or by adding a general filter similar to bevel or emboss from image editing apps or a relief sculpture. They can&#39;t recognize the angles of the face, for example, but attempt to guess where there should be a change in an angle. It&#39;s a limitation, but they&#39;re still useful for generating the normal maps of sprite sections that are beveled, like chains, cables, or a dragon&#39;s tail, and also surface normals for bricks, stones, wood, and others.</p>
<p>Import a section into the normal map generator, tweak the values, export, and then add the necessary parts and details yourself.</p>
<p><img src="_page_80_Picture_4.jpeg" alt=""></p>
<p>Generating crevices in normal map by using Emboss tool in Sprite Illuminator</p>
<p><span id="page-81-0"></span>For the last technique, Unity offers a way to generate normal maps from a grayscale heightmap. This is a texture where black represents the minimum surface height and white the maximum height. You need to import an image as a normal map and check the Create from Grayscale option. This technique is handy for quickly generating normal maps without ever leaving the engine.</p>
<p>When using this method, the Bumpiness slider will appear in the Inspector. Unity uses pixel brightness and converts the height differences to normal map angles, and this slider controls the steepness of those angles. A low bumpiness value means that even a sharp contrast in the heightmap will be translated into softer angles and bumps.</p>
<table>
<thead>
<tr>
<th>Texture Type</th>
<th>Normal map</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>Texture Shape</td>
<td>2D</td>
<td>D</td>
</tr>
<tr>
<td>Ignore PNG file gamma<br>Create from Grayscale</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Bumpiness</td>
<td></td>
<td>0.12</td>
</tr>
<tr>
<td>Filtering</td>
<td>Smooth</td>
<td>D</td>
</tr>
</tbody>
</table>
<p>Converting texture to normal map using Create from Grayscale option</p>
<h4 id="-how-to-paint-normal-maps-onto-sprites-"><strong>How to paint normal maps onto sprites</strong></h4>
<p>To paint a normal map, start by learning which colors to use for different angles.</p>
<p>First, obtain a normal map palette so you can sample the colors used to represent the surface angles. Find palettes online, or simply use the palette of colors from the normal maps chapter image. No matter how your painting workflow looks, you&#39;ll only need to copy a palette to your favorite painting app and use the color picker to select a color to paint on your normal map.</p>
<p>Angle colors don&#39;t need to be 100% accurate; a few degrees won&#39;t make a difference. However, be sure to keep the overall shape of the sprite believable. If you use an angle color that doesn&#39;t make sense in-context, the whole shape will fall apart when lit.</p>
<p>Painting normal maps can be tricky initially because it requires a good spatial imagination. A great place to start is with something simple like the base planes of the head. This simplified model of a human head has a low-poly look, and you can check out this prepared <a href="https://images.response.unity3d.com/Web/Unity/%7B9c8dcb76-9772-4a8a-8295-ef9b30147ca8%7D_base-head-template-image.zip">example here</a>.</p>
<p>When painting a normal map, try to imagine the basic 3D shapes that are parts of your sprite, then visualize the angles of each individual part. If you know the angle, you&#39;ll know from which part of the palette sprite to sample the color.</p>
<p><img src="_page_82_Picture_0.jpeg" alt=""></p>
<p>How to sample an angle from a normal map palette.</p>
<p>This example is working on a flat surface, but the process is similar when you&#39;re painting with softer brushes. You can blend hard edges to achieve a more natural look.</p>
<p>A couple of shortcuts to note: When there&#39;s a spherical shape, you can paste the normal sphere from your palette. When you have a cylindrical shape, you can take a part of the sphere, paste and stretch it, or make a gradient.</p>
<p>Be aware that copying and pasting parts of normal maps and rotating them breaks the shading. However, this can also be used to your advantage. For example, when you need a concave spherical shape, just rotate the sphere 180 degrees to create a hole.</p>
<p>For a normal map to show on one or more sprites, you need to enable normal map function on lights.</p>
<table>
<thead>
<tr>
<th>Use Normal Map</th>
<th>&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td>Distance</td>
<td>4</td>
</tr>
<tr>
<td>Quality</td>
<td>Accurate<br>D</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>Normal map support settings on 2D Light</p>
<p>Choose the method of generating normal maps that works best for you. Most likely there will be many assets made for your game, so focus on the objects that will be most visible and simplify the other parts of the game.</p>
<p><img src="_page_83_Picture_0.jpeg" alt=""></p>
<p>This is how the normal map looks on a white sprite in-engine.</p>
<h4 id="some-tools-that-can-help-include-">Some tools that can help include:</h4>
<ul>
<li><a href="https://green-frisbee.itch.io/normalpainter">NormalPainter</a></li>
<li><a href="https://docs.krita.org/en/reference_manual/brushes/brush_engines/tangen_normal_brush_engine.html">Krita&#39;s Tangent Normal Brush</a></li>
<li><a href="https://www.codeandweb.com/spriteilluminator">SpriteIlluminator</a></li>
<li><a href="https://azagaya.itch.io/laigter">Laigter</a></li>
<li><a href="http://www.snakehillgames.com/spritelamp/">Sprite Lamp</a></li>
</ul>
<h2 id="adding-rim-lighting-with-mask-maps">Adding rim lighting with Mask Maps</h2>
<p>Rim lighting is an effect that&#39;s used to highlight the contours of a character. It simulates light coming from behind an object and the natural properties of light scattering. This is called the Fresnel effect. In real life, more light reflects from objects when the angle where the light hits the surface is wider.</p>
<p><img src="_page_83_Figure_10.jpeg" alt=""></p>
<p>Illustration of the Fresnel effect</p>
<p>That&#39;s why the water in a lake is more reflective from a distance, but we can see our feet in the water when we look down. This is also why objects are more reflective on their edges.</p>
<p>In 2D graphics, you can simulate this effect by using an additional texture called Mask Map and a special light called Blend Style.</p>
<p><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@10.7/manual/LightBlendStyles.html">Blend Styles</a> determine the way a particular light interacts with sprites in a scene. Light Blend Styles are located in the 2D Renderer asset.</p>
<table>
<thead>
<tr>
<th>0 Inspector</th>
<th></th>
<th></th>
<th>a</th>
<th>: ■×</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>New 2D Renderer Data (Renderer 2D Data)</td>
<td></td>
<td></td>
<td></td>
<td>@ :</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Open</td>
<td></td>
</tr>
<tr>
<td>Transparency Sort Mode</td>
<td>Custom Axis</td>
<td></td>
<td></td>
<td></td>
<td>▶</td>
</tr>
<tr>
<td>Transparency Sort Axis</td>
<td>X 0</td>
<td>Y 1</td>
<td>Z O</td>
<td></td>
<td></td>
</tr>
<tr>
<td>HDR Emulation Scale</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Light Blend Styles</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>▼ Default</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Name</td>
<td>Default</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mask Texture Channel</td>
<td>None</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Render Texture Scale</td>
<td></td>
<td></td>
<td></td>
<td>0.5</td>
<td></td>
</tr>
<tr>
<td>Blend Mode</td>
<td>Multiply</td>
<td></td>
<td></td>
<td></td>
<td>V</td>
</tr>
<tr>
<td>▼ Rim Light</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Name</td>
<td>Rim Light</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mask Texture Channel</td>
<td>R</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Render Texture Scale</td>
<td></td>
<td></td>
<td></td>
<td>0.5</td>
<td></td>
</tr>
<tr>
<td>Blend Mode</td>
<td>Additive</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Unused</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&gt; Unused</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Use Depth /Stencil Buffer</td>
<td>&gt;</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Post-processing Data</td>
<td>C PostProcessData (Post Process Data)</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>Default Material Type</td>
<td>Lit</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Asset Labels</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>AssetBundle<br>None</td>
<td></td>
<td>&gt;</td>
<td>None</td>
<td></td>
</tr>
</tbody>
</table>
<p>Setting Light Blend Styles options in 2D Renderer Data asset</p>
<p>Under Light Bend Styles are four options for different blending styles. Leave the first option untouched because it&#39;s the default one, and instead work on the second option.</p>
<p>Give it a name like &quot;Rim Light&quot; or &quot;Fresnel&quot; or whatever works for you. Set the Mask Texture channel to R – lights will use the red color of our Mask Map texture. Lastly, set the Blend Mode to Additive. This will make lights be added on top of existing lighting, increasing the brightness.</p>
<h4 id="-span-id-page-85-0-span-painting-the-mask-map-"><span id="page-85-0"></span><strong>Painting the Mask Map</strong></h4>
<p>Fresnel light uses the red channel of the Mask Map, but for the sake of simplicity, let&#39;s paint in black and white. The parts that will reflect light will be white, and the unreflective parts will be black. The Fresnel effect impacts the edges of objects, so copy the base sprite, paint it black, then highlight the edges white. It should start to resemble an object that has a bright light shining behind it. To speed things up, add an Inner Glow effect on the object, and paint some details on top. Unfortunately, there&#39;s no app that can speed up this process, so you&#39;ll need to rely on your painting skills here.</p>
<p><img src="_page_85_Picture_2.jpeg" alt=""></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>Mask Map for a base plane</th>
</tr>
</thead>
<tbody>
<tr>
<td>head sprite</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="-setting-fresnel-light-"><strong>Setting Fresnel light</strong></h4>
<p>To make the light affect the Mask Map, change its Blend Style to the one created earlier.</p>
<table>
<thead>
<tr>
<th>Alpha Blend on Overlap</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Light Order</td>
<td>O</td>
<td></td>
</tr>
<tr>
<td>Blend Style</td>
<td>Rim Light</td>
<td>&gt;</td>
</tr>
<tr>
<td>Color</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>Intensity</td>
<td>7.23</td>
<td></td>
</tr>
<tr>
<td>Use Normal Map</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Distance</td>
<td>0.21</td>
<td></td>
</tr>
<tr>
<td>Quality</td>
<td>Accurate</td>
<td>&gt;</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Changing light&#39;s Blend Style to Rim Light</p>
<p><img src="_page_86_Picture_0.jpeg" alt=""></p>
<p>Editing shapes in the Shadow Caster 2D component</p>
<p>Fresnel lights work best with the Use Normal Maps option enabled and with Distance set to a low value. This prevents highlighting the other side of the object.</p>
<h4 id="adding-2d-shadows-with-2d-lights">Adding 2D shadows with 2D Lights</h4>
<p>2D Lights can also cast shadows onto a scene. For a GameObject to cast a shadow from 2D light, add a Shadow Caster 2D component to the object.</p>
<p><img src="_page_86_Picture_5.jpeg" alt=""></p>
<p>Rim lighting effect on a sprite in the Unity Editor</p>
<p>Use the Shadow Caster&#39;s shape editor to edit its geometry so it fits the object&#39;s silhouette. The light also needs to have some options set to cast a shadow.</p>
<table>
<thead>
<tr>
<th>Volume Opacity</th>
<th></th>
<th>0.407</th>
</tr>
</thead>
<tbody>
<tr>
<td>Shadow Intensity</td>
<td>0 1</td>
<td></td>
</tr>
<tr>
<td>Shadow Volume Intensity</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Target Sorting Layers</td>
<td>Default</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>2D Lights options used when using shadows</p>
<p><span id="page-87-0"></span>Use the Shadow Intensity option to see the shadow. This setting determines the light&#39;s opacity on other objects that are in the shadows. When it&#39;s set to 1, the light will not illuminate anything in the shadow area.</p>
<p>You can also make the area affected by light visible by using the Volume Opacity option. The Shadow Volume Intensity controls the opacity of the light volume in the shadow area.</p>
<p><img src="_page_87_Picture_2.jpeg" alt=""></p>
<p><em>Among Us</em> by InnerSloth. Apart from enhancing the visual side of games, shadows can also be a crucial part of the gameplay.</p>
<h2 id="how-to-use-2d-lights-on-different-renderers">How to use 2D Lights on different renderers</h2>
<p>2D Lights can be used together with normal maps and mask maps on sprites, but you can also use them on different renderers. Let&#39;s see how.</p>
<h4 id="-2d-tilemap-"><strong>2D Tilemap</strong></h4>
<p>To use 2D Lights on Tilemaps, assign the normal map and mask map textures to the sprites that are used as tiles by using the Sprite Editor&#39;s Secondary Textures module. Secondary textures will be used automatically by the 2D Lights system.</p>
<p><img src="_page_87_Picture_8.jpeg" alt=""></p>
<p><em>Tilemaps with Secondary Maps</em></p>
<p><span id="page-88-0"></span><img src="_page_88_Picture_0.jpeg" alt=""></p>
<p>2D Lights with normal mapping and mask maps on 2D Tilemap</p>
<h4 id="-2d-sprite-shape-"><strong>2D Sprite Shape</strong></h4>
<p>The <a href="https://docs.unity3d.com/Packages/com.unity.2d.spriteshape@5.1/manual/index.html">Sprite Shape Renderer</a> uses two different materials per object: one for Fill and one for Edge. The Edge Material uses Secondary Maps from the Sprite asset. For the Fill area, use the texture with wrap mode set to Repeat for tiling instead of the sprite. You&#39;ll need to create a new Fill material with Material Property Block enabled for setting secondary textures.</p>
<table>
<thead>
<tr>
<th>T B V Sprite Shape Renderer</th>
<th></th>
<th></th>
<th></th>
<th>3</th>
<th>2</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Color</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>00</td>
</tr>
<tr>
<td>Mask Interaction</td>
<td></td>
<td>None</td>
<td></td>
<td></td>
<td></td>
<td>V</td>
</tr>
<tr>
<td>Fill Material</td>
<td></td>
<td>@ grass_dirt</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>Edge Material</td>
<td></td>
<td>Sprite-Lit-Default</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>Additional Settings</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Sorting Layer</td>
<td></td>
<td>Default</td>
<td></td>
<td></td>
<td></td>
<td>&gt;</td>
</tr>
<tr>
<td>Order in Layer</td>
<td></td>
<td>O</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Rendering Layer Mask</td>
<td></td>
<td>Layer1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Sprite-Lit-Default (Material)</td>
<td></td>
<td></td>
<td></td>
<td>0 花 :</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Shader Universal Render Pipeline/2D/Sprite-Lit-Default</td>
<td></td>
<td></td>
<td></td>
<td>Edit</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Grass_dirt (Material)</td>
<td></td>
<td></td>
<td></td>
<td>2 花</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Shader Universal Render Pipeline/2D/Sprite-Lit-Default</td>
<td></td>
<td></td>
<td></td>
<td>Edit</td>
<td></td>
</tr>
<tr>
<td>Diffuse</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>None</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>(Texture)</td>
<td></td>
</tr>
<tr>
<td>X<br>Tiling</td>
<td>1</td>
<td></td>
<td>Y 1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Offset</td>
<td>× 0</td>
<td></td>
<td>Y O</td>
<td></td>
<td>Select</td>
<td></td>
</tr>
<tr>
<td>Mask</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Tiling</td>
<td>×<br>1</td>
<td></td>
<td>Y 1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>×<br>Offset</td>
<td>0</td>
<td></td>
<td>Y O</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Normal Map</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>×<br>Tiling</td>
<td>1</td>
<td></td>
<td>Y 1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Offset</td>
<td>× 0</td>
<td></td>
<td>Y O</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Example of Sprite Shape GameObjects using normal maps</p>
<p><span id="page-89-0"></span><img src="_page_89_Picture_0.jpeg" alt=""></p>
<p>Example of Sprite Shape GameObjects using normal maps</p>
<h4 id="-2d-psd-importer-for-animated-characters-"><strong>2D PSD Importer for animated characters</strong></h4>
<p>Setting Secondary Textures in the 2D PSD Importer works similarly, with one minor difference regarding normal maps.</p>
<p>The fastest way to make a normal map and mask map for a 2D PSD imported character is by working from a base character .PSB file.</p>
<ul>
<li><ol>
<li>Complete these steps to add a normal map to an animated character:</li>
</ol>
</li>
<li><ol>
<li>Duplicate the base character .PSB file. Rename the duplicated file by adding a suffix to its name, for example: _normal</li>
</ol>
</li>
<li><ol>
<li>Open this file in your preferred image editor, and paint a normal map onto each layer. Save the file.</li>
</ol>
</li>
<li><ol>
<li>When a PSB with a normal map is imported into Unity, you&#39;ll need to set the Texture Type to Sprite and go into Advanced settings to uncheck sRGB(Color Texture) option. A normal map doesn&#39;t contain color sRGB data, only angle values.</li>
</ol>
</li>
<li><ol>
<li>Assign this PSB file as a Secondary Texture of your base character.</li>
</ol>
</li>
</ul>
<p>To make a mask map, repeat the process, give the duplicated file another suffix, and just skip step 3.</p>
<p><img src="_page_90_Picture_0.jpeg" alt=""></p>
<p>Adding a normal map to an animated character</p>
<h2 id="optimization-tips">Optimization tips</h2>
<ul>
<li>Avoid using too many lights in a Scene.</li>
<li>Use as few Sorting layers and Light Blend Styles as possible.</li>
<li>Set a lower value for the Render Texture Scale in Light Blend Styles of 2D Renderer assets.</li>
<li>When using normal maps, set normal lighting Quality of lights to Fast instead of Accurate.</li>
<li>Use 2D Shadows on only a few lights.</li>
</ul>
<h2 id="-span-id-page-91-0-span-advanced-visual-effects-"><span id="page-91-0"></span><strong>Advanced visual effects</strong></h2>
<p>Visual effects (VFX) are the cherry on top of any great-looking game, and they&#39;re vital to the gamers&#39; experience as they play. VFX communicate game events such as environmental hazards and healing zones, and they <a href="https://resources.unity.com/games/game-designer-playbook?ungated=true">visually</a>  <a href="https://resources.unity.com/games/game-designer-playbook?ungated=true">reward the player</a> <a href="https://create.unity3d.com/game-designer-playbook?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">f</a>or well-executed actions, like an action scene culminating in a big, fiery explosion.</p>
<p>Unity provides lots of options to add VFX to your game. You can add frameby-frame animations made in other software, animate particles, or add animated shaders.</p>
<h3 id="frame-by-frame-animations">Frame-by-frame animations</h3>
<p>Frame-by-frame (or flipbook) animation lets you add effects quickly in Unity. Simply import frames as sprites, then animate the Sprite Property over time in the Animation window. You can also select and drag all the frame sprites into the Scene, which will then animate them automatically.</p>
<p>While importing frames is fast, drawing each frame to be animated is not, and this process can require much more time and skill than you have available. To save time, you can instead export VFX as frames from other apps.</p>
<p>Another shortcut you can use is to select all of the animation frame assets from the Project view, and drag them to the Hierarchy view or Scene. A new GameObject will then be created with an animation that uses the sequence made of the previously selected images.</p>
<p>The flipbook animation technique is very performant, so use it when you want to have many instances of the effect onscreen. Remember that many frames in high resolution will require more memory.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>O</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Animation<br>Preview ® He IE D DI DH</td>
<td>1 1</td>
<td>0</td>
<td></td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
</tr>
<tr>
<td>New Animation - - - - Samples 12 - Samples 12 - - -   -</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>▼ [s fire_animation : Sprite</td>
<td>�</td>
<td>�<br>C</td>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>Add Property</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Frame-by-frame animation of a flame</p>
<p>Frame-by-frame animation can also be used in <a href="https://docs.unity3d.com/Manual/ParticleSystems.html">Particle Systems,</a> where it is referred to as Texture Sheet Animation.</p>
<table>
<thead>
<tr>
<th>V Texture Sheet Animation</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Mode</td>
<td>Sprites</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>· None (Sprite)</td>
<td>0 4</td>
<td></td>
</tr>
<tr>
<td>Time Mode</td>
<td>Lifetime</td>
<td>L</td>
<td></td>
</tr>
<tr>
<td>Frame over Time</td>
<td></td>
<td>œ</td>
<td></td>
</tr>
<tr>
<td>Start Frame</td>
<td>O</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Cycles</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Affected UV Channels</td>
<td>Everything</td>
<td>b</td>
</tr>
</tbody>
</table>
<p>Setting up frame-by-frame animation in Particle System</p>
<p>Flipbook animations can also be used in the Shader Graph by animating the UV position of texture over time, which creates the illusion of moving frames.</p>
<p><img src="_page_92_Figure_6.jpeg" alt=""></p>
<p>Flipbook animation in Shader Graph</p>
<h2 id="particles">Particles</h2>
<p>The Particle System allows you to display and animate many smaller images or meshes in order to achieve a single visual effect. Particle properties like size, velocity, color, and rotation can be animated over time using certain predefined rules and randomization. This allows you to create dynamic effects like fire, explosions, smoke, magic spells, and so on.</p>
<p>You create a new Particle System by selecting the menu option <strong>GameObject &gt; Effects &gt; Particle System</strong>.</p>
<table>
<thead>
<tr>
<th>್ಕೆ<br>&gt;<br>Particle System</th>
<th></th>
<th>8 花<br></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>Open Editor</td>
</tr>
<tr>
<td>Particle System</td>
<td></td>
<td>+</td>
</tr>
<tr>
<td>Duration</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>Looping</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Prewarm</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Start Delay</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>Start Lifetime</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td>Start Speed</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td>3D Start Size</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Start Size</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>3D Start Rotation</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Start Rotation</td>
<td>O</td>
<td>&gt;</td>
</tr>
<tr>
<td>Flip Rotation</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>Start Color</td>
<td></td>
<td>&gt;</td>
</tr>
<tr>
<td>Gravity Modifier</td>
<td>O</td>
<td>◀</td>
</tr>
<tr>
<td>Simulation Space</td>
<td>Local</td>
<td>▶</td>
</tr>
<tr>
<td>Simulation Speed</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>Delta Time</td>
<td>Scaled</td>
<td>&gt;</td>
</tr>
<tr>
<td>Scaling Mode</td>
<td>Local</td>
<td>&gt;</td>
</tr>
<tr>
<td>Play On Awake*</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Emitter Velocity</td>
<td>Rigidbody</td>
<td>▶</td>
</tr>
<tr>
<td>Max Particles</td>
<td>1000</td>
<td></td>
</tr>
<tr>
<td>Auto Random Seed</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Stop Action</td>
<td>None</td>
<td>&gt;</td>
</tr>
<tr>
<td>Culling Mode</td>
<td>Automatic</td>
<td>&gt;</td>
</tr>
<tr>
<td>Ring Buffer Mode</td>
<td>Disabled</td>
<td>&gt;</td>
</tr>
<tr>
<td>V Emission</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Shape</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Velocity over Lifetime</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Limit Velocity over Lifetime</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Inherit Velocity</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Lifetime by Emitter Speed</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Force over Lifetime</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Color over Lifetime</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Color by Speed</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Size over Lifetime</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Size by Speed</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Rotation over Lifetime</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Rotation by Speed</td>
<td></td>
<td></td>
</tr>
<tr>
<td>External Forces</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Noise</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Collision</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Triggers</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Sub Emitters</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Texture Sheet Animation</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Lights</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Trails</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Custom Data</td>
<td></td>
<td></td>
</tr>
<tr>
<td>V Renderer</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Particle System properties</p>
<h4 id="-span-id-page-94-0-span-main-module-properties-"><span id="page-94-0"></span><strong>Main Module properties</strong></h4>
<p>The Particle System has many modules, but let&#39;s cover a few of the essentials.</p>
<p>The first module contains basic particle properties:</p>
<ul>
<li>Duration: How long the system will run</li>
<li>Looping: Whether the whole system will loop forever</li>
<li>Speed: The initial speed of the particles</li>
<li>Start Size: The initial size of the particles</li>
<li>Color: The initial color of the particles</li>
<li>Gravity: Gravity force applied to the particles</li>
</ul>
<h4 id="-emission-"><strong>Emission</strong></h4>
<p>Emission controls the rate and timing of emitted particles, while Rate controls how many particles are emitted per unit of time. You can also create bursts of particles, specifying how many to spawn and when.</p>
<h4 id="-shape-"><strong>Shape</strong></h4>
<p>This module defines the volume or surface from which particles can be emitted, and the direction that they will travel. The Shape property defines the shape of the emission volume.</p>
<h4 id="-color-over-lifetime-"><strong>Color over Lifetime</strong></h4>
<p>You can control the particles&#39; color and opacity over its lifetime by evaluating the gradient. On the left of the gradient is the starting color, and on the right is the color particles will have when they die.</p>
<h4 id="-size-over-lifetime-"><strong>Size Over Lifetime</strong></h4>
<p>This setting defines the size of a particle along the horizontal axis of a curve.</p>
<h4 id="-rotation-over-lifetime-"><strong>Rotation Over Lifetime</strong></h4>
<p>Rotation over Lifetime gives particles a rotation speed.</p>
<h4 id="-noise-"><strong>Noise</strong></h4>
<p>This module will add randomness to the particle movement. It&#39;s a very quick way to add interesting and complex-looking effects like magic spells, sci-fi energy, exhaust fire, dust motes, and more.</p>
<h4 id="-span-id-page-95-0-span-renderer-"><span id="page-95-0"></span><strong>Renderer</strong></h4>
<table>
<thead>
<tr>
<th>✓ Renderer</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Render Mode</td>
<td>Billboard</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>D</td>
</tr>
<tr>
<td>Normal Direction</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Material</td>
<td>C Sprite-Lit-Default</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>Sort Mode</td>
<td>None</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&gt;</td>
</tr>
<tr>
<td>Sorting Fudge</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Min Particle Size</td>
<td>O</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Max Particle Size</td>
<td>0.5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Render Alignment</td>
<td>View</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Flip</td>
<td>X<br>O</td>
<td>Y</td>
<td>0</td>
<td>Z</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>Allow Roll</td>
<td>V</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pivot</td>
<td>×<br>O</td>
<td>Y</td>
<td>0</td>
<td>Z</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>Visualize Pivot</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Masking</td>
<td>No Masking</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&gt;</td>
</tr>
<tr>
<td>Apply Active Color Space</td>
<td>&gt;</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Custom Vertex Streams</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cast Shadows</td>
<td>Off</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>œ</td>
</tr>
<tr>
<td>Shadow Bias</td>
<td>O</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Sorting Layer ID</td>
<td>Default</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&gt;</td>
</tr>
<tr>
<td>Order in Layer</td>
<td>O</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Light Probes</td>
<td>Off</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>▶</td>
</tr>
<tr>
<td>Reflection Probes</td>
<td>Off</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>▶</td>
</tr>
<tr>
<td>Rendering Layer Mask</td>
<td>Layer1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>▶</td>
</tr>
</tbody>
</table>
<p>The Renderer module</p>
<p>The Renderer module, as seen above, allows you to change how particles will look. There are many settings, but the most important to change is the Material setting, where you can add a new material with a texture.</p>
<h4 id="-randomized-particles-"><strong>Randomized particles</strong></h4>
<table>
<thead>
<tr>
<th>3D Start Size</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Start Size</td>
<td></td>
<td>V</td>
</tr>
<tr>
<td>3D Start Rotation</td>
<td></td>
<td>V<br>Constant</td>
</tr>
<tr>
<td>Start Rotation</td>
<td>O</td>
<td></td>
</tr>
<tr>
<td>Flip Rotation</td>
<td>O</td>
<td>Curve</td>
</tr>
<tr>
<td>Start Color</td>
<td></td>
<td>Random Between Two Constants</td>
</tr>
<tr>
<td>Gravity Modifier</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>Simulation Space</td>
<td>Local</td>
<td>Random Between Two Curves</td>
</tr>
<tr>
<td>Simulation Speed</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Delta Time</td>
<td>Scaled</td>
<td>D</td>
</tr>
<tr>
<td>Scaling Mode</td>
<td>Local</td>
<td>D</td>
</tr>
</tbody>
</table>
<p>Random particle property</p>
<p>Most of the particle properties can be randomized to achieve an unpredictable and natural look.</p>
<p>The dropdown menu to the right of the particle property allows you to choose from different randomization options.</p>
<p>Particle Systems can also be nested within one another. Nesting causes systems to play simultaneously, which allows you to achieve some very complex effects. For example, to create an explosion, you could combine one system for smoke, one for small sparks, and one for flying debris.</p>
<p>The Particle System is a very powerful tool that allows you to create almost any VFX for your game. You can even make your effects glow using HDR unlit shader and Bloom post-processing. Test out every property, for even the simplest particles will make your game feel polished.</p>
<p>To speed up your game creation process significantly, check the Asset Store for <a href="https://assetstore.unity.com/vfx/particles?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">premade particle VFX.</a></p>
<h2 id="-span-id-page-96-0-span-shader-graph"><span id="page-96-0"></span>Shader Graph</h2>
<p>Another way to make VFX is using shaders. Shaders are a set of instructions for the graphics processor, and they can, for example, calculate pixel colors or vertex positions.</p>
<p><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@10.7/manual/index.html">Shader Graph</a> enables you to build shaders visually. Instead of writing code, you create and connect nodes in a graph framework. Shader Graph gives instant feedback that reflects your changes, and it&#39;s simple enough for users who are new to shader creation.</p>
<p>With the Shader Graph you can:</p>
<ul>
<li>Warp and animate UVs</li>
<li>Procedurally alter surface appearance</li>
<li>Ad image filters similar to image editing apps</li>
<li>Change an object&#39;s surface based on information like world location, normals, distance from the camera, and more</li>
<li>Tweak shader visuals in a Scene&#39;s context by exposing properties to Material Inspector</li>
</ul>
<h4 id="-using-the-shader-graph-"><strong>Using the Shader Graph</strong></h4>
<p>To start using the Shader Graph for 2D, go to the Project window, right-click, and select <strong>Create &gt; Shader &gt; Universal Render Pipeline &gt; Sprite Lit Shader Graph</strong> (or <strong>Sprite Unlit Shader Graph</strong>).</p>
<p>Use Sprite Lit Shader when you want your sprite to be affected by lights, which will be the case for almost all characters and objects. Use Sprite Unlit for unlit or emissive surfaces such as fire, light sources, electricity, spells, holograms, or special characters like ghosts.</p>
<p>To start creating a shader, name the file first. This will create your initial shader. Then, double-click the file to enter Edit mode.</p>
<table>
<thead>
<tr>
<th>First Shader<br>Save Asset   Save As _ Show In Project Check Out</th>
<th></th>
<th></th>
<th>×0 !<br>Color Mode &gt; &lt; None&gt; Blackboard Graph Inspector Main Preview</th>
</tr>
</thead>
<tbody>
<tr>
<td>First Shader<br>+<br>Chadler Graphs<br>Properties<br>Keywords</td>
<td>Vertex<br>Object Space · - O Position(3)<br>Object Space · - O Normal (3)<br>Object Space · - O Tangent(3)<br>Fragment</td>
<td>Procision<br>Universal<br>v Universal<br>Material</td>
<td>Graph Inspector<br>Node Settings Graph Settings<br>Singlo<br>Target Settings<br>Active Targets<br>+ -<br>Sprito Lit<br>Custom Editor GUI</td>
</tr>
<tr>
<td></td>
<td>· - O Base Collor(3)<br>· - O Sprite Mask(4)<br>Tangent Space · · · O Normal (Tangent Space)(3)<br>· · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · ·</td>
<td></td>
<td>Main Preview</td>
</tr>
</tbody>
</table>
<p>This opens the Shader Graph window. Within the central part, called the Workspace, is the Master Stack. This is the final output of the Shader Graph, which is responsible for the shader&#39;s ultimate look. There should only be one Master Stack per shader.</p>
<p>The Master Stack contains two Contexts, which correspond to vertex and fragment (or pixel) functions.</p>
<p>On the left hand, you&#39;ll see a Blackboard. This contains properties that will be visible in the Inspector and Keywords.</p>
<p>At the top right is a Graph Inspector, which has two tabs: Node settings, which allows you to change a selected Node&#39;s settings, and Graph Settings, which changes the entire graph&#39;s settings. From the Inspector, you can switch the Precision mode; this is a good idea to set it to half on low-end devices. You can also swap the shader Material between lit and unlit.</p>
<p>The Main Preview at the bottom is where you can view the final shader.</p>
<p>The nodes in Shader Graph are the building blocks that hold inputs, effects, and interactions. A graph proceeds from left to right, so nodes will have input slots on the left, and outputs on the right.</p>
<p>To add a new node, right-click anywhere on the workspace, and choose <strong>Create Node</strong> from the context menu. You&#39;ll be presented with a list of all nodes grouped by type. Select <strong>Input &gt; Texture &gt; Sample Texture 2D</strong>.</p>
<p><img src="_page_97_Figure_7.jpeg" alt=""></p>
<p>An example of a Texture 2D node</p>
<p>Connect the RGBA(4) slot of the Sample Texture 2D node to the Base Color(3) in the Master Stack&#39;s input slot. Connect the A(1) slot to Alpha(1). Now, the Master Stack&#39;s Fragment Context will use the color and alpha of the texture you provide to the Sample Texture 2D node.</p>
<p><img src="_page_98_Figure_1.jpeg" alt=""></p>
<p>To reference this texture from outside the shader, you need a property.</p>
<p>Exposed properties will show in the Inspector view where you can modify the parameters that will be used in the Graph.</p>
<p>Click the Plus button located on the Blackboard, and select Texture 2D. Select the newly created property, and options will appear in the Graph Inspector. You can change the property&#39;s name, but more important is the Reference option – change this to _MainTex.</p>
<p>For the texture, use the sprite, which is set in every Sprite Renderer. Sprite Renderer will check for _MainTex property in the current Material&#39;s shader and will set its sprite texture as the texture in the shader. Finally, drag this property from the Blackboard to the workspace, and connect it to the Texture(T2) input slot on the Sample Texture 2D node. Hit the Save Asset button on the toolbar, and the shader will be compiled.</p>
<p>You can use the Shader Graph just like any other shader in Unity. Right-click in the Project window, choose <strong>Create &gt; Material</strong>, and select your shader from the list. All of its properties will be available to customize.</p>
<p>You can test your shader by applying the created material to a sprite. Of course, this is the simplest shader with just a texture. Feel free to experiment and try out the rest of the nodes. Or maybe you can try to add a normal map and Mask Map (Sprite Mask) to this shader? Hints: Sample Texture 2D Type needs to be set to Normal to correctly display normal map, and you can check reference names of Normal Map and Mask Map textures in the Secondary Textures window in the Sprite Editor. Good luck!</p>
<p><img src="_page_99_Picture_0.jpeg" alt=""></p>
<p>Secondary Textures for the barrel sprite. You can check their names and add your own textures that can be referenced in Shader Graph by name.</p>
<h2 id="vertex-displacement">Vertex displacement</h2>
<p>The Vertex displacement shader affects the positions of vertices in a geometry of the mesh. You can displace vertices in many ways, and the simplest way is to apply a moving noise. This shader is good for waving objects: foliage, hanging vines and ropes, flags, and so on. You can find an example of this Shader Graph file in the <em>Dragon Crashers</em> project, with the file name <em>ShaderGraph_Sprite_Lit_Waving.</em></p>
<p><img src="_page_99_Figure_4.jpeg" alt=""></p>
<p>Main part of Waving shader</p>
<p>To achieve the wave animation, Gradient Noise is used as a wave mask. Its UV Offset is animated by the Time node multiplied by a Float named Speed. These all affect the position of vertices in the Vertex Context.</p>
<p><img src="_page_100_Figure_1.jpeg" alt=""></p>
<p>The Vertex context in Shader Graph modifies the vertices position and the Fragment master stack the pixel information.</p>
<p>The sprite that will be affected by the Waving shader needs to have a sufficient vertex count, otherwise the animation will look rough. To edit the vertices, use Skinning Editor Geometry tools.</p>
<p><img src="_page_100_Figure_4.jpeg" alt=""></p>
<p>Editing vertices</p>
<p><img src="_page_101_Picture_0.jpeg" alt=""></p>
<p>Cobweb shader in action <a href="https://www.google.com/url?q=https://youtu.be/gJ40FxUJnZ4&amp;sa=D&amp;source=docs&amp;ust=1639508737131000&amp;usg=AOvVaw3Vj0uwRHjGjY34apt20QUW">(click</a> through to see the animation).</p>
<h4 id="flow-maps">Flow maps</h4>
<p>Flow maps are textures that store directional information. You can find a flow map shader in the Dragon Crashers demo, with the name ShaderGraph_Lava. The shader uses the flow map texture to control the direction of the main texture&#39;s UV coordinates. The colors red and green are used to indicate the XY direction that pixels follow in every frame, making the pixels of the main texture &quot;flow.&quot;</p>
<p>Open the SubGraph FlowMap to learn how to achieve this effect.</p>
<p><img src="_page_101_Figure_5.jpeg" alt=""></p>
<p>Flow map texture colors explained: The red color controls pixel movement on X axis, green color determines on the Y axis. The shader moves the pixels of the main texture in the directions that are visualized by the arrows.</p>
<p><img src="_page_102_Picture_0.jpeg" alt=""></p>
<p>The hand-painted flow map gives the stream of lava a viscous and cartoonish effect, which matches the project&#39;s art direction. A couple of tools you can use for flow map creation include <a href="https://cables.gl/p/ntZfmv">Flow Map Generator / Visualizer</a> and <a href="https://clemensbeute.gumroad.com/#heZDT">Flow map painter</a>.</p>
<h2 id="threshold-animations-for-fluid-prop-animation">Threshold animations for fluid prop animation</h2>
<p>Another shader animation technique you can try is called &quot;animated alpha clipping,&quot; which creates smooth animation from a single texture. This occurs by showing a specific range of pixels in each frame based on their alpha values. The texture is single channel, so the effect is simple to achieve. Find an example of it in <em>Dragon Crashers</em> with the name <em>ShaderGraph_Sprite_Unlit_ ThresholdAnim</em>.</p>
<p><img src="_page_102_Picture_4.jpeg" alt=""></p>
<p>Animated alpha clipping</p>
<p>To achieve this effect, a Smoothstep node is used. The texture&#39;s red channel is connected to the In(1) slot, and Vertex Color alpha controls the evaluation of the edge and smoothness of the Smoothstep effect. Vertex Color is controlled by the Color property of the Sprite Renderer, so when you change the opacity of the sprite, the texture is animated. This allows the shader to be usable, even on particles.</p>
<p>If you use Affinity Photo, you can paint the texture for this shader black and white, then preview the animation by using Threshold Adjustment while moving the value slider.</p>
<p><img src="_page_103_Picture_1.jpeg" alt=""></p>
<p>Previewing threshold animation in Affinity Photo</p>
<p><img src="_page_103_Picture_3.jpeg" alt=""></p>
<p>Texture used for the lava effect and how it looks in-game (see how it looks animated <a href="https://blog-api.unity.com/sites/default/files/2021-03/splatteralphafading.gif">here</a>)</p>
<p>This effect achieves the look of fluids or splatters, without the need for frameby-frame animation. You can learn more about this animation in the <a href="https://www.gdcvault.com/play/1020476/Surface-Tension-Liquid-Effects-in">Surface</a>  <a href="https://www.gdcvault.com/play/1020476/Surface-Tension-Liquid-Effects-in">Tension</a> community post.</p>
<h4 id="-span-id-page-104-0-span-reflections-and-refractions-"><span id="page-104-0"></span><strong>Reflections and refractions</strong></h4>
<p>One of the most common 2D techniques deals with reflections and refractions, like those you see on water, ice, glass, or in hot air. To achieve this effect, another camera outputs the parts that will be reflected or refracted into a render texture. This texture is then used in a shader, distorted and adjusted as needed, and finally outputted onto the screen.</p>
<p><img src="_page_104_Picture_2.jpeg" alt=""></p>
<p>The setup process for water reflections, created with <em><a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673?utm_source=blog&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Lost Crypt</a></em> demo shader files named ShaderGraph Water Unlit</p>
<h2 id="adding-glow-around-lights">Adding glow around lights</h2>
<p>To make sprites glow with blinding light, combine the HDR enhanced sprite shader with the Bloom post-processing effect.</p>
<p><img src="_page_104_Picture_6.jpeg" alt=""></p>
<p>HDR shader in <em>Dragon Crashers</em> (ShaderGraph_Sprite_Unlit_HDRTint)</p>
<p>To make this blinding light effect, multiply texture by a Color node that uses HDR Color Mode. In the Material, crank up the HDR value over 1, with the Bloom post-processing effect enabled on the main camera.</p>
<h4 id="sprite-masking">Sprite masking</h4>
<p>Sprite Masks are used to either hide or reveal parts of a sprite or group of sprites. For example, you could hide part of an image to produce a portal effect or make a collectible card with a 3D effect.</p>
<p>To create a Sprite Mask, go to the menu and select <strong>GameObject &gt; 2D Object &gt; Sprite Mask.</strong> Next, choose a sprite to be used as a mask shape. Keep in mind that the mask sprite itself will not be visible. Set the Sorting Layers on which the mask will work.</p>
<p><img src="_page_105_Picture_4.jpeg" alt=""></p>
<p>Portal Effect created with Sprite Mask and the Particle System</p>
<p>The sprite used as the mask image can itself be animated with the animation tool. This enables you to create some interesting effects. For example, you can make a portal appear, then grow bigger or change shape.</p>
<p>Mask Sprites need to have their Mask Interaction set in the Sprite Renderer in order to be affected by a Sprite Mask. In the URP&#39;s 2D Renderer, the Depth/ Stencil Buffer must be enabled.</p>
<p><img src="_page_105_Figure_8.jpeg" alt=""></p>
<p>Depth/Stencil Buffer option used for masking</p>
<h2 id="comparison-of-tools">Comparison of tools</h2>
<h4 id="-2d-skeletal-animation-vs-frame-by-frame-animation-"><strong>2D skeletal animation vs frame-by-frame animation</strong></h4>
<table>
<thead>
<tr>
<th>Frame by frame</th>
<th></th>
<th>2D skeletal</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Pros</td>
<td>Cons</td>
<td>Pros</td>
<td>Cons</td>
<td></td>
</tr>
<tr>
<td>• Artistic look<br>• Can animate<br>everything (easy<br>rotation of character)<br>• Little runtime cost</td>
<td>• Costly to make (time,<br>skill)<br>• Difficult to edit later<br>• Consumes large<br>amounts of memory<br>• The animation will<br>always be limited<br>to the frames per<br>second that it was<br>created forthey<br>need to be manually<br>authored if changes<br>to the speed or frame<br>rate of the animation<br>are required</td>
<td>• Easy to set up and<br>animate<br>• Easy to edit later<br>• Small texture size<br>• Can support multiple<br>characters or skins<br>per skeleton<br>• Can be edited at<br>runtime to add<br>clothes, weapons,<br>animating IK, and<br>so on<br>• Animation will<br>always be smooth –<br>interpolation<br>• animations can be<br>blended to create<br>smooth transitions</td>
<td>• Some runtime cost<br>• Animations like<br>rotating around Y<br>axis are more difficult<br>• Doesn&#39;t work well<br>with pixel art</td>
<td></td>
</tr>
<tr>
<td>Use when you:</td>
<td></td>
<td>Use when you:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>•<br>Want a great aesthetic or specific style<br>•<br>Focus on pixel art animation<br>•<br>Want simple animation of just a few frames</td>
<td></td>
<td>•<br>Don&#39;t have strong animation skills<br>•<br>Want to make animation quickly<br>•<br>Want multiple skins or characters<br>•<br>Want a better runtime control<br>•<br>Want to save texture space</td>
<td></td>
<td></td>
</tr>
<tr>
<td>expressions can be driven by sprite swaps.</td>
<td></td>
<td>Both techniques can be mixed. The movement of limbs can be driven by bones, but facial</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="-shaders-animation-vs-animation-clips-for-vfx-vs-particle-system-"><strong>Shaders animation vs animation clips for VFX vs Particle System</strong></h4>
<table>
<thead>
<tr>
<th>Shaders</th>
<th></th>
<th>Animation clips</th>
<th></th>
<th>Particle System</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Pros</td>
<td>Cons</td>
<td>Pros</td>
<td>Cons</td>
<td>Pros</td>
<td>Cons</td>
</tr>
<tr>
<td>• Achieves<br>effects not<br>possible<br>with other<br>techniques<br>• Procedural<br>effects<br>• Fast<br>creation<br>time<br>• Small<br>texture size</td>
<td>• Runtime<br>calculation<br>are hard</td>
<td>• Looks great<br>• Artistic<br>control on<br>animation<br>and its<br>frames</td>
<td>• Texture size<br>• Takes<br>more time<br>to create<br>individual<br>frames<br>• Hard to<br>customize<br>later</td>
<td>• Easy to<br>make and<br>edit later<br>• Can<br>randomize<br>to define a<br>unique look</td>
<td>• Complex<br>effects<br>• Require<br>a lot of<br>particles<br>which can<br>be taxing to<br>CPU</td>
</tr>
<tr>
<td>Use when you:<br>• Want simple animation of just<br>a few frames Good for effects<br>that otherwise would take a lot<br>of space/memory when done<br>frame by frame<br>• Great when you need<br>customization<br>• Great for applying effects on<br>materials</td>
<td></td>
<td>Use when you:<br>• Good for natural- or cartoon<br>looking animations (insects,<br>birds, smoke effects, etc.)<br>• Very low runtime cost</td>
<td></td>
<td>Use when you:<br>• Good for effects with a bit of<br>randomization like fire, fluids,<br>and magic spells</td>
</tr>
</tbody>
</table>
<h4 id="-tilemaps-vs-sprite-vs-sprite-shape-"><strong>Tilemaps vs Sprite vs Sprite Shape</strong></h4>
<table>
<thead>
<tr>
<th>Tilemaps</th>
<th></th>
<th>Sprites</th>
<th></th>
<th>Sprite Shape</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Pros</td>
<td>Cons</td>
<td>Pros</td>
<td>Cons</td>
<td>Pros</td>
<td>Cons</td>
</tr>
<tr>
<td>• Fast<br>creation<br>process for<br>painting,<br>tiles, and<br>rule tiles<br>• Precise<br>• Good for<br>optimizing<br>games</td>
<td>• Difficult to<br>to make<br>organic<br>shapes<br>when<br>constrained<br>to a grid</td>
<td>• Great for<br>placing<br>objects<br>manually</td>
<td>• Hard to<br>paint<br>multiple<br>sprites<br>• Not<br>optimized<br>when used<br>in large<br>numbers</td>
<td>• Easy editing<br>of both<br>polygonal<br>and organic<br>shapes</td>
<td>• Doesn&#39;t allow<br>for pixel<br>perfect<br>• placement<br>easily<br>• Textures can<br>be repetitive</td>
</tr>
<tr>
<td>Use when you:<br>• Good for precise placement of<br>level elements<br>• Grid is good for pathfinding</td>
<td></td>
<td>Use when you:<br>• Good for additional elements, as<br>a supplement to Tilemaps and<br>Sprite Shape</td>
<td></td>
<td>Use when you:<br>• Great for organic-looking shapes<br>• Fast level editing</td>
<td></td>
</tr>
<tr>
<td>• Very versatile</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="optimization-tips">Optimization tips</h2>
<ul>
<li>Try to maintain a low frame count/texture size when using frame-by-frame animation.</li>
<li>With <a href="https://learn.unity.com/tutorial/introduction-to-object-pooling">Object Pooling</a>, you can avoid instantiating and destroying VFX assets. Simply activate and deactivate GameObjects.</li>
<li>In the Shader Graph, use half precision whenever possible.</li>
</ul>
<h2 id="-span-id-page-109-0-span-post-processing-"><span id="page-109-0"></span><strong>Post-processing</strong></h2>
<h2 id="overview">Overview</h2>
<p>Post-processing enhances the look of your game by adding effects on the final image frame. These effects can simulate a physical video camera look or be completely stylized. The URP includes <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@10.7/manual/integration-with-post-processing.html?utm_source=blog&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">post-processing capabilities</a>, so there&#39;s no need to install a separate package, and configuring the effects is straight-forward.</p>
<p><img src="_page_109_Picture_3.jpeg" alt=""></p>
<p>On the left is an image of a camera output without post-processing. On the right is the same image with post-processing added. The effects have been exaggerated to show the difference. Apply post-processing effects cautiously, especially in mobile games.</p>
<h4 id="to-begin-select-the-main-camera-and-select-the-post-processing-option-">To begin, select the main camera, and select the Post Processing option.</h4>
<table>
<thead>
<tr>
<th>T Rendering</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Renderer</td>
<td>Default Renderer (New 2D Renderer Data)</td>
<td>D</td>
</tr>
<tr>
<td>Post Processing</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Anti-aliasing</td>
<td>None</td>
<td>D</td>
</tr>
<tr>
<td>Stop NaN</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Dithering</td>
<td></td>
</tr>
</tbody>
</table>
<p>Enabling Post Processing in the main camera</p>
<p>Post-processing uses the <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@10.7/manual/Volumes.html?utm_source=blog&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Volume</a> system so to add a new post-processing Volume, select <strong>GameObject &gt; Volume &gt; Global Volume.</strong></p>
<table>
<thead>
<tr>
<th>▼ ▼ √ Volume</th>
<th></th>
<th></th>
<th>9 花 :</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Mode</td>
<td>Global</td>
<td></td>
<td></td>
<td>D</td>
</tr>
<tr>
<td>Weight</td>
<td></td>
<td>3 1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Priority</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Profile</td>
<td>None (Volume Profile)</td>
<td>0</td>
<td>New</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Defining a Volume Profile</p>
<p>Now, create a Volume Profile by clicking the New button. Volume Profile will store your post-processing effects and can be easily shared between Volumes and Scenes.</p>
<p>To start adding post-processing effects, click the Add Override button, then select a desired effect from the list.</p>
<p><img src="_page_110_Picture_2.jpeg" alt=""></p>
<p>Selecting the Bloom post-processing effect</p>
<p>Let&#39;s choose Bloom to start with.</p>
<table>
<thead>
<tr>
<th>J Bloom<br>&gt;<br>All None</th>
<th></th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bloom</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&gt;<br>Threshold</td>
<td>0.87</td>
<td></td>
</tr>
<tr>
<td>&gt;<br>Intensity</td>
<td>1.48</td>
<td></td>
</tr>
<tr>
<td>Scatter</td>
<td></td>
<td>0.7</td>
</tr>
<tr>
<td>1<br>Tint</td>
<td></td>
<td>A</td>
</tr>
<tr>
<td>Clamp</td>
<td>65472</td>
<td></td>
</tr>
<tr>
<td>_ High Quality Filtering</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Skip Iterations<br>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Lens Dirt</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Dirt Texture</td>
<td>None (Texture)</td>
<td>O</td>
</tr>
<tr>
<td>Dirt Intensity<br>ﺎ ﺍﻟﻤﺴﺎﺣﺔ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤ</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Defining Bloom effect properties</p>
<p><span id="page-111-0"></span>To adjust the effect&#39;s property, select the adjacent checkbox.</p>
<p>A quick reminder: Ensure that the Global Volume&#39;s GameObject layer matches the layer selected in the Mask option on the main camera.</p>
<table>
<thead>
<tr>
<th>8<br>Static ▼<br>V Main Camera<br>Static ▼<br>V Global Volume<br>B<br>· Layer Post Processing<br>Tag Untagged<br>Tag MainCamera<br>· Layer Default<br>J Transform<br>9 2<br>V 2<br>Transform<br>0 2 :<br>11<br>Position<br>X 30,54515<br>Y 2.711628<br>Z 0.02922535<br>Position<br>× 0<br>Y O<br>Z -10<br>Rotation<br>× 0<br>Y O<br>ZO<br>Rotation<br>× 0<br>Y O<br>Z O<br>Z 1<br>Scale<br>× 1<br>Y 1<br>Z 1<br>Scale<br>× 1<br>Y 1<br>0 2 1<br>v Camera<br>V Volume<br>9 # 1<br>Base<br>-<br>Mode<br>Global<br>Render Type<br>@ 1<br>Weight<br>v Projection<br>0<br>Priority<br>Orthographic<br>Projection<br>Profile<br>Global Volume Profile (Volume Profile) O New Clone<br>Sizo<br>5<br>V J Bloom<br><br>Clipping Planes<br>Near 0.3<br>All None<br>Far 1000<br>Bloom<br>v Rendering<br>Threshold<br>0.87<br>Renderer<br>Default Renderer (New 2D Renderer Data)<br>V Intensity<br>1.48<br>Scatter<br>0.7<br>&gt;<br>Post Processing<br>Tint<br>Anti-aliasing<br>None<br>Clamp<br>65472<br>Stop NaN<br>High Quality Filtering<br>Dithering<br>Skip Iterations<br>1<br>V<br>Render Shadows<br>Lens Dirt<br>-1<br>Priority<br>Dirt Texture<br>0<br>None (Texture)<br>Use Pipeline Settings<br>Opaque Texture<br>Dirt Intensity<br>0<br>4<br>Depth Texture<br>Use Pipeline Settings<br>Culling Mask<br>Everything<br>4<br>Add Override<br>Occlusion Culling<br>&gt;<br>Add Component<br>v Environment<br>-<br>Background Type<br>Skybox<br>Volumes<br>Post Processing<br>Mask<br>0<br>Trigger<br>Nothing<br>Update Mode<br>Everything<br>Default<br>T Output<br>0<br>Output Texture<br>TransparentFX<br>HDR<br>Ignore Raycast<br>MSAA<br>Water<br>Viewport Rect<br>UI<br>Post Processing<br>Allow Dynamic Resolution<br>4<br>Target Display<br>Display 1<br>Both<br>Target Eye<br>v Stack<br>List is Empty<br>+ -</th>
<th>O Inspector</th>
<th></th>
<th></th>
<th></th>
<th>a : D× 0 Inspector</th>
<th></th>
<th></th>
<th>a : Ox</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>If everything is working correctly, the Bloom effect should be visible in the Game view.</p>
<p>Make sure the Post Processing check box in the camera is enabled and that the Layer of the Volume&#39;s GameObject is selected in the Volumes Mask drop list of the camera</p>
<p>Global Volume was used, so the effects should always be visible when the Volume object is active in the Scene.</p>
<h4 id="-local-volumes-"><strong>Local Volumes</strong></h4>
<p>You can add post-processing effects to an entire level, but it&#39;s also possible to configure effects for parts of a level, such as when the player enters a building.</p>
<p>To do that, another Volume Object must be created with a different postprocessing Profile attached.</p>
<p>Volume&#39;s Mode needs to be set as Local, then add the 3D Box Collider to the</p>
<p><img src="_page_112_Picture_0.jpeg" alt=""></p>
<p>Adding a 3D Box Collider to a Volume Object</p>
<p>Volume Object. Post-processing will be applied when the camera enters the Box Collider&#39;s bounds, so make sure its along the Z axis is large enough to contain the camera object. By default, the collider will be too small, so double check the size by in Scene view.</p>
<p>Increasing the Blend Distance value will prevent the effects turning on abruptly when the camera enters the Volume zone.</p>
<h2 id="-span-id-page-113-0-span-overview-of-effects-for-2d-graphics"><span id="page-113-0"></span>Overview of effects for 2D graphics</h2>
<p>Post-processing in URP has many built-in effects, and almost every effect can be used in a 2D game. Here&#39;s a quick overview of the effects.</p>
<h4 id="-bloom-"><strong>Bloom</strong></h4>
<p><img src="_page_113_Picture_3.jpeg" alt=""></p>
<p>The Bloom effect creates a glow around the brightest areas of the image, giving the impression that parts are brighter to simulate how a lens captures light. To further enhance the look, try adding a Lens Dirt texture, which will simulate the imperfections on a camera lense. For best performance, disable High Quality Filtering, especially on mobile.</p>
<p><img src="_page_113_Picture_5.jpeg" alt=""></p>
<h4 id="-chromatic-aberration-"><strong>Chromatic Aberration</strong></h4>
<p>This effect creates color distortion on the edges of an image. This simulates lenses that split colors further away from the center.</p>
<h4 id="-span-id-page-114-0-span-color-grading-"><span id="page-114-0"></span><strong>Color Grading</strong></h4>
<p>This is a group of effects rather than a single one. The purpose of color grading is to alter the colors of an image to stylize or change the mood of a scene. Color grading can simulate the time of day or temperature of an environment by adjusting its color temperature. These effects have the potential to give a game a very distinct look.</p>
<p>The URP uses the following effects to control Color Grading.</p>
<p><img src="_page_114_Picture_3.jpeg" alt=""></p>
<p><img src="_page_114_Picture_4.jpeg" alt=""></p>
<p>Channel Mixer: Modifies the influence of each input color channel on the final image</p>
<p><img src="_page_114_Picture_6.jpeg" alt=""></p>
<p>Color Lookup: Performant way of color grading by using a single texture</p>
<p><img src="_page_114_Picture_8.jpeg" alt=""></p>
<p><img src="_page_114_Picture_9.jpeg" alt=""></p>
<p>Lift Gamma Gain: Performs three-way color grading</p>
<p><img src="_page_114_Picture_11.jpeg" alt=""></p>
<p>Color Curves: Allows precise color and luminance adjustments to an image</p>
<p><img src="_page_114_Picture_13.jpeg" alt=""></p>
<p>Shadows Midtones Highlights: Separately controls the shadows, midtones, and highlights of an image</p>
<p><img src="_page_114_Picture_15.jpeg" alt=""></p>
<p>Split Toning: Tints different areas of the image based on luminance values, adding hints of different colors to shadows, midtones, and highlights</p>
<p><img src="_page_114_Picture_17.jpeg" alt=""></p>
<p>Tonemapping: Allows remapping the HDR values of an image to a new range of values</p>
<p><img src="_page_114_Picture_19.jpeg" alt=""></p>
<p>White Balance: Balances color temperature and can also cool or warm the tone of an image</p>
<h4 id="-span-id-page-115-0-span-lens-distortion-"><span id="page-115-0"></span><strong>Lens Distortion</strong></h4>
<p><img src="_page_115_Picture_1.jpeg" alt=""></p>
<p>This will create a barrel distortion effect commonly seen in real-world wide-angle lenses. This curves the straight lines on an image inwards, and it will be more pronounced closer to edges. This effect can be used to replicate an old CRT TV curvature or add a fisheye lens effect.</p>
<h4 id="-vignette-"><strong>Vignette</strong></h4>
<p><img src="_page_115_Picture_4.jpeg" alt=""></p>
<p>Vignette darkens the image towards the edges, which is another real-life lens property that draws attention to the center of an image.</p>
<h4 id="-span-id-page-116-0-span-film-grain-"><span id="page-116-0"></span><strong>Film Grain</strong></h4>
<p><img src="_page_116_Picture_1.jpeg" alt=""></p>
<p>Film Grain applies subtle noise over the image, producing an effect similar to a film negative&#39;s emulsion structure and resulting visible grain in analog movies.</p>
<h4 id="-panini-projection-"><strong>Panini Projection</strong></h4>
<p><img src="_page_116_Picture_4.jpeg" alt=""></p>
<p>Designed to help render perspective views with a very large field of view, Panini Projection can also be used in 2D to stylize the image with a cylindrical distortion.</p>
<h2 id="optimization-tips">Optimization tips</h2>
<ul>
<li>Use as few post-processing effects as possible.</li>
<li>Use less intensive effects, such as Bloom, Chromatic Aberration, Color Grading, Lens Distortion, or Vignette, wherever possible.</li>
<li>Film Grain and Panini Projection are more costly.</li>
<li>Disable High Quality Filtering on Bloom</li>
</ul>
<h2 id="-span-id-page-117-0-span-conclusion-"><span id="page-117-0"></span><strong>Conclusion</strong></h2>
<p>You&#39;ve come a long way by getting to the end of this guide. I hope the steps and knowledge presented here will help you start on your journey to creating beautiful 2D games in Unity.</p>
<p>Over the years, we&#39;ve encountered many people who struggle with game development, those who seem to think there is always one more step to learn or tutorial to watch before they can really start. But the best way to learn is by doing. So start now.</p>
<p>Once you take that first step, yes, there&#39;s a good chance you&#39;ll hit a few roadblocks. But then you might have to dive into a tutorial or technical article or get some good tips from a fellow developer, and you&#39;ll be back on your way again.</p>
<p>Game development requires you to both do and learn. It will always be a balance between the two.</p>
<p>It&#39;s not possible to explore every area of 2D game development in just one e-book. But this is a good reference to keep close at hand as you kick off your project and deepen your knowledge of these tools. There are many additional resources for developers and artists, including Unity <a href="https://docs.unity.com/?utm_source=blog&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Documentation,</a> <a href="https://learn.unity.com/?utm_source=blog&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Unity</a>  <a href="https://learn.unity.com/?utm_source=blog&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">Learn,</a> and <a href="https://blog.unity.com/?utm_source=blog&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-2d&amp;utm_content=2d-game-art,-animation-and-lighting-ebook">the Unity Blog</a></p>
<p>Good luck!</p>
<p>– Jarek Majewski and the Unity 2D team</p>
<p><img src="_page_118_Picture_0.jpeg" alt=""></p>
<p><a href="https://unity.com/">unity.com</a></p>
</body></html>